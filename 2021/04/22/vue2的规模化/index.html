<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> vue2的规模化 · Chio's Personal Website</title><meta name="description" content="vue2的规模化 - Chio"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/chio.github.io/favicon.png"><link rel="stylesheet" href="/chio.github.io/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://chiokotomi.github.io/chio.github.io/atom.xml" title="Chio's Personal Website"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/chio.github.io/atom.xml" title="Chio's Personal Website" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/chio.github.io/" class="logo-link"><img src="/chio.github.io/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/chio.github.io/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/chio.github.io/archives/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="https://weibo.com/u/2001366581" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/chiokotomi" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">vue2的规模化</h1><div class="post-info">Apr 22, 2021</div><div class="post-content"><p><strong>Vue是一个用于构建用户界面的渐进式框架</strong>，对于已存在的服务端应用，可将vue作为应用的一部分嵌入；如果将更多的业务逻辑放在前端，也可以用vue的核心库与生态系统来实现。</p>
<span id="more"></span>
<p>Vue核心库只关注视图层。</p>
<h1 id="安装介绍"><a href="#安装介绍" class="headerlink" title="安装介绍"></a>安装介绍</h1><h2 id="不支持IE8"><a href="#不支持IE8" class="headerlink" title="不支持IE8"></a>不支持IE8</h2><p>实现<code>响应式系统</code>是使用<code>Object.defineProperty</code>来遍历<code>data</code>选项把所有的<code>property</code>转化为<code>getter/setter</code></p>
<p><code>Object.defineProperty</code>是ES5中一个无法shim的特性，这就是Vue2不支持IE8的原因。</p>
<h2 id="版本发布遵循语义化版本控制"><a href="#版本发布遵循语义化版本控制" class="headerlink" title="版本发布遵循语义化版本控制"></a>版本发布遵循语义化版本控制</h2><p>遵循<a target="_blank" rel="noopener" href="https://semver.org/lang/zh-CN/">语义化版本控制</a></p>
<h2 id="构建版本"><a href="#构建版本" class="headerlink" title="构建版本"></a>构建版本</h2><ul>
<li>编译器： 用来将模板字符串编译成为JavaScript渲染函数的代码<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要编译器</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    template: <span class="string">&#x27;&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>运行时： 用来创建Vue实例、渲染并处理虚拟DOM等的代码。基本上就是除去编译器的其他一切。<strong>运行时版本比完整版体积小大约30%</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要编译器</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    render (h) &#123;</span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">this</span>.hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>完整版： 编译器+运行时</li>
</ul>
<h1 id="非侵入性的响应式系统"><a href="#非侵入性的响应式系统" class="headerlink" title="非侵入性的响应式系统"></a>非侵入性的响应式系统</h1><p><strong>响应式系统：</strong>修改数据模型(普通的js对象)时，视图会进行更新。这使得状态管理非常简单直接。</p>
<h2 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h2><blockquote>
<p>针对Vue实例的<code>data</code>选项（一般都传入普通的js对象）</p>
</blockquote>
<p>Vue2遍历此对象的所有<code>property</code>，使用<code>Object.defineProperty</code>把所有的<code>property</code>转化为<code>getter/setter</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue2代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">target: <span class="built_in">Object</span>, sourceKey: string, key: string</span>) </span>&#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[sourceKey][key]</span><br><span class="line">  &#125;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[sourceKey][key] = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些<code>getter/setter</code>对用户不可见，在内部可以让Vue能追踪依赖，在property被访问和修改时通知变更。<br>每个组件实例对应一个<code>watcher</code>实例，会在组件渲染的过程中把接触过的数据<code>property</code>记录为依赖，之后当依赖项的<code>setter</code>触发时，会通知<code>watcher</code>，从而使他关联的组件重新渲染。</p>
<p><img src="vue-data-watcher-render.jpg"></p>
<p>需要注意的事：</p>
<ul>
<li><p>由于js的限制，vue不能检测数组与对象的变化，使用<code>Vue.set/vm.$set</code>方法更改<code>data</code>中对象或数组的值保证他们的响应性。</p>
</li>
<li><p>data根级响应式的property不可以动态添加，必须在初始化实例时声明所有的响应式property。主要目的时消除在依赖项跟踪系统中的一类边界情况。同时提高代码的可维护性，<code>data</code>对象就像组件状态的<code>结构(schema)</code></p>
</li>
<li><p>使用Object.freeze()会阻止修改现有的property，响应系统将无法追踪变化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: obj</span><br><span class="line">&#125;)</span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;!-- 这里的 <span class="string">&#x27;foo&#x27;</span> 不会更新 --&gt;</span><br><span class="line">  &lt;button v-on:click=<span class="string">&quot;foo = &#x27;baz&#x27;&quot;</span>&gt;Change it&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h2><p>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。<br><code>Vue,nextTick(callback)</code>回调函数将在DOM更新完成后被调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">Vue.component(<span class="string">&#x27;example&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">&#x27;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&#x27;</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;未更新&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.message = <span class="string">&#x27;已更新&#x27;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;未更新&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;已更新&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 或使用ES2017 async/await</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  updateMessage: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.message = <span class="string">&#x27;已更新&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;未更新&#x27;</span></span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">this</span>.$nextTick()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;已更新&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Vue将模板编译成虚拟DOM渲染函数"><a href="#Vue将模板编译成虚拟DOM渲染函数" class="headerlink" title="Vue将模板编译成虚拟DOM渲染函数"></a>Vue将模板编译成虚拟DOM渲染函数</h1><h1 id="组件化应用构建"><a href="#组件化应用构建" class="headerlink" title="组件化应用构建"></a>组件化应用构建</h1><p>组件的本质：一个拥有预定义选项的Vue实例<br>大型应用中，将整个应用程序划分为组件，使开发更易管理。</p>
<h2 id="Vue组件与自定义元素（custom-elements）的关系"><a href="#Vue组件与自定义元素（custom-elements）的关系" class="headerlink" title="Vue组件与自定义元素（custom elements）的关系"></a>Vue组件与自定义元素（custom elements）的关系</h2><ul>
<li>自定义元素：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components">web组件（Web Components）规范</a>的一部分</li>
<li>相同点：<ul>
<li>Vue组件语法参考了web组件规范（例如slot API 与 <code>is</code> attribute）</li>
</ul>
</li>
<li>不同点：<ul>
<li>web components规范已通过，但并未被所有浏览器原生实现。然而vue组件不需要任何polyfill，并支持ie9及以上。必要时，Vue组件也可以包装于原生自定义元素之内。</li>
<li>vue组件提供了自定义元素所不具备的一些功能，例如<code>跨组件数据流</code>、<code>自定义事件通信</code>、<code>构建工具集成</code></li>
</ul>
</li>
</ul>
<h2 id="Vue实例生命周期图示"><a href="#Vue实例生命周期图示" class="headerlink" title="Vue实例生命周期图示"></a>Vue实例生命周期图示</h2><p><img src="lifecycle.png"></p>
<h2 id="父子组件单向数据流"><a href="#父子组件单向数据流" class="headerlink" title="父子组件单向数据流"></a>父子组件单向数据流</h2><p>所有的<code>prop</code>使得父子<code>prop</code>之间形成了一个<code>单向下行绑定</code>。以防止子组件意外更改父组件的状态，从而导致应用的数据流向难以理解。双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件都没有明显的变更来源</p>
<h2 id="过渡效果系统"><a href="#过渡效果系统" class="headerlink" title="过渡效果系统"></a>过渡效果系统</h2><p>Vue插入、更新、移除元素时自动应用过渡效果</p>
<h1 id="可复用性-amp-组合"><a href="#可复用性-amp-组合" class="headerlink" title="可复用性&amp;组合"></a>可复用性&amp;组合</h1><ul>
<li><p>mixin</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myMixin = &#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> Component = Vue.extend(&#123;</span><br><span class="line">  mixins: [myMixin]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> component = <span class="keyword">new</span> Component();</span><br></pre></td></tr></table></figure></li>
<li><p>自定义指令<code>Vue.directive()</code></p>
</li>
<li><p>渲染函数<code>render</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;xxx-xxx&#x27;</span>, &#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(</span><br><span class="line">      <span class="string">&#x27;h&#x27;</span> + <span class="built_in">this</span>.level,</span><br><span class="line">      <span class="built_in">this</span>.$slots.default</span><br><span class="line">    ),</span><br><span class="line">    props: &#123;</span><br><span class="line">      level: &#123;</span><br><span class="line">        type: <span class="built_in">Number</span>,</span><br><span class="line">        required: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过<code>babel插件@vue/babel-preset-jsx</code>可以使用jsx语法，接近于模板的语法上，Vue的模板实际上也是被编译成了渲染函数<code>Vue.compile</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;AnchoredHeading level=&#123;<span class="number">1</span>&#125;&gt;</span><br><span class="line">        &lt;span&gt;Hello&lt;/span&gt; world!</span><br><span class="line">      &lt;/AnchoredHeading&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>虚拟DOM：Vue通过建立一个虚拟DOM来追踪自己要如何改变真实DOM<br><code>createElement</code>返回一个虚拟节点<code>virtual node/VNode</code>包含信息告诉Vue页面上需要渲染什么样的节点，包括及其子节点的信息描述。</p>
</li>
</ul>
<h1 id="Vue插件"><a href="#Vue插件" class="headerlink" title="Vue插件"></a>Vue插件</h1><p>插件通常用来为 Vue 添加全局功能，如<code>vue-loader</code></p>
<h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p><code>Vue.use()</code>在调用<code>new Vue()</code>启动应用之前</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(MyPlugin)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="规模化"><a href="#规模化" class="headerlink" title="规模化"></a>规模化</h1><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NotFound = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;Page not found&lt;/p&gt;&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> Home = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;home page&lt;/p&gt;&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> About = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;about page&lt;/p&gt;&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = &#123;</span><br><span class="line">  <span class="string">&#x27;/&#x27;</span>: Home,</span><br><span class="line">  <span class="string">&#x27;/about&#x27;</span>: About</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    currentRoute: <span class="built_in">window</span>.location.pathname</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ViewComponent () &#123;</span><br><span class="line">      <span class="keyword">return</span> routes[<span class="built_in">this</span>.currentRoute] || NotFound</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render (h) &#123; <span class="keyword">return</span> h(<span class="built_in">this</span>.ViewComponent) &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>类Flux架构，store模式，集中式状态管理，组件不允许直接变更属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，这样能够记录所有 store 中发生的 state 变更，同时实现能做到记录变更、保存状态快照、历史回滚/时光旅行的先进的调试工具。<br><img src="./state.png"></p>
<h2 id="服务端渲染SSR"><a href="#服务端渲染SSR" class="headerlink" title="服务端渲染SSR"></a>服务端渲染SSR</h2><p>将一个组件渲染为服务端的HTML字符串，直接发送到浏览器，再将静态标记“激活”为客户端上可以交互的应用程序<br>使用SSR可以</p>
<ul>
<li>更好的SEO：搜索引擎爬虫工具可以直接查看完全渲染的页面</li>
<li>更快的内容到达时间（time-to-content）<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3>使用<code>vue-server-renderer</code>渲染一个Vue实例<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> renderer = <span class="built_in">require</span>(<span class="string">&#x27;vue-server-renderer&#x27;</span>).createRenderer(&#123;</span><br><span class="line">  template,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> context = &#123;</span><br><span class="line">    title: <span class="string">&#x27;vue ssr&#x27;</span>,</span><br><span class="line">    metas: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;meta name=&quot;keyword&quot; content=&quot;vue,ssr&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;meta name=&quot;description&quot; content=&quot;vue srr demo&quot;&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">server.get(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      url: req.url</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`&lt;div&gt;访问的 URL 是： &#123;&#123; url &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  renderer</span><br><span class="line">  .renderToString(app, context, <span class="function">(<span class="params">err, html</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(html);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      res.status(<span class="number">500</span>).end(<span class="string">&#x27;Internal Server Error&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.end(html);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>
<h3 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h3><blockquote>
<p>运行在服务器与客户端的代码</p>
</blockquote>
</li>
<li>服务器上默认情况下禁用响应式数据</li>
<li>生命周期只有<code>beforeCreate</code>与<code>created</code>会在服务端渲染过程中被调用，避免在期间产生有全局副作用的代码</li>
<li>通用代码不接受特定平台的API，如<code>window</code>或<code>document</code></li>
</ul>
<h3 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h3><ul>
<li>使用webpack对client与node端代码进行构建<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用app.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出一个工厂函数，用于创建新的</span></span><br><span class="line"><span class="comment">// 应用程序、router 和 store 实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// 根实例简单的渲染应用程序组件。</span></span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123; app &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// entry-client：将app挂载到dom上进行渲染执行</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; app &#125; = createApp()</span><br><span class="line"></span><br><span class="line">app.$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// entry-server：ssr中直接调用app，后续再执行</span></span><br><span class="line"><span class="comment">// 服务器端路由匹配 server-side route matching</span></span><br><span class="line"><span class="comment">// 和 数据预取逻辑 data pre-fetching logic</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> context =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; app &#125; = createApp()</span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="路由与代码分割"><a href="#路由与代码分割" class="headerlink" title="路由与代码分割"></a>路由与代码分割</h3><ul>
<li>路由</li>
<li>惰性加载（懒加载）：减少初始渲染中下载的资源体积，改善大体积bundle的可交互时间（time-to-interactive）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">&#x27;./Foo.vue&#x27;</span></span><br><span class="line"><span class="comment">// 改为</span></span><br><span class="line"><span class="keyword">const</span> Foo = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./Foo.vue&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="数据预取和状态"><a href="#数据预取和状态" class="headerlink" title="数据预取和状态"></a>数据预取和状态</h3><p><img src="https://ssr.vuejs.org/zh/guide/data.html" alt="数据预取和状态基于vuex"></p>
<h3 id="客户端激活"><a href="#客户端激活" class="headerlink" title="客户端激活"></a>客户端激活</h3><p> Vue 在浏览器端接管由服务端发送的静态 HTML，使其变为由 Vue 管理的动态 DOM 的过程。<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span> data-server-rendered=<span class="string">&quot;true&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="comment">// 强制使用应用程序的激活模式</span></span><br><span class="line">app.$mount(<span class="string">&#x27;#app&#x27;</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="预渲染Prerendering"><a href="#预渲染Prerendering" class="headerlink" title="预渲染Prerendering"></a>预渲染Prerendering</h2><p>改善少数页面的SEO使用预渲染<br>在构建时简单地生成针对特定路由的静态HTML文件</p>
</div></article></div></main><footer><div class="paginator"><a href="/chio.github.io/2021/04/23/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/" class="prev">PREV</a><a href="/chio.github.io/2021/04/20/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/" class="next">NEXT</a></div><div class="copyright"><p>© 2020 - 2021 <a href="https://chiokotomi.github.io/chio.github.io">Chio</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>
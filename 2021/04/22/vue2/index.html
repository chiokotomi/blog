<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> vue2学习笔记 · Chio's Personal Website</title><meta name="description" content="vue2学习笔记 - Chio"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/chio.github.io/favicon.png"><link rel="stylesheet" href="/chio.github.io/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://chiokotomi.github.io/chio.github.io/atom.xml" title="Chio's Personal Website"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/chio.github.io/atom.xml" title="Chio's Personal Website" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/chio.github.io/" class="logo-link"><img src="/chio.github.io/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/chio.github.io/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/chio.github.io/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/2001366581" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/chiokotomi" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">vue2学习笔记</h1><div class="post-info">Apr 22, 2021</div><div class="post-content"><blockquote>
<p><strong>Vue是一个用于构建用户界面的渐进式框架</strong>，对于已存在的服务端应用，可将vue作为应用的一部分嵌入；如果将更多的业务逻辑放在前端，也可以用vue的核心库与生态系统来实现。<br>Vue核心库只关注视图层。</p>
</blockquote>
<span id="more"></span>

<h1 id="安装介绍"><a href="#安装介绍" class="headerlink" title="安装介绍"></a>安装介绍</h1><h2 id="不支持IE8"><a href="#不支持IE8" class="headerlink" title="不支持IE8"></a>不支持IE8</h2><p>实现<code>响应式系统</code>是使用<code>Object.defineProperty</code>来遍历<code>data</code>选项把所有的<code>property</code>转化为<code>getter/setter</code></p>
<p><code>Object.defineProperty</code>是ES5中一个无法shim的特性，这就是Vue2不支持IE8的原因。</p>
<h2 id="版本发布遵循语义化版本控制"><a href="#版本发布遵循语义化版本控制" class="headerlink" title="版本发布遵循语义化版本控制"></a>版本发布遵循语义化版本控制</h2><p>遵循<a target="_blank" rel="noopener" href="https://semver.org/lang/zh-CN/">语义化版本控制</a></p>
<h2 id="构建版本"><a href="#构建版本" class="headerlink" title="构建版本"></a>构建版本</h2><ul>
<li>编译器： 用来将模板字符串编译成为JavaScript渲染函数的代码<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要编译器</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    template: <span class="string">&#x27;&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>运行时： 用来创建Vue实例、渲染并处理虚拟DOM等的代码。基本上就是除去编译器的其他一切。<strong>运行时版本比完整版体积小大约30%</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要编译器</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    render (h) &#123;</span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">this</span>.hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>完整版： 编译器+运行时</li>
</ul>
<h1 id="非侵入性的响应式系统"><a href="#非侵入性的响应式系统" class="headerlink" title="非侵入性的响应式系统"></a>非侵入性的响应式系统</h1><p><strong>响应式系统：</strong>修改数据模型(普通的js对象)时，视图会进行更新。这使得状态管理非常简单直接。</p>
<h2 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h2><blockquote>
<p>针对Vue实例的<code>data</code>选项（一般都传入普通的js对象）</p>
</blockquote>
<p>Vue2遍历此对象的所有<code>property</code>，使用<code>Object.defineProperty</code>把所有的<code>property</code>转化为<code>getter/setter</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue2代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">target: <span class="built_in">Object</span>, sourceKey: string, key: string</span>) </span>&#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[sourceKey][key]</span><br><span class="line">  &#125;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[sourceKey][key] = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些<code>getter/setter</code>对用户不可见，在内部可以让Vue能追踪依赖，在property被访问和修改时通知变更。<br>每个组件实例对应一个<code>watcher</code>实例，会在组件渲染的过程中把接触过的数据<code>property</code>记录为依赖，之后当依赖项的<code>setter</code>触发时，会通知<code>watcher</code>，从而使他关联的组件重新渲染。</p>
<p><img src="vue-data-watcher-render.jpg"></p>
<p>需要注意的事：</p>
<ul>
<li><p>由于js的限制，vue不能检测数组与对象的变化，使用<code>Vue.set/vm.$set</code>方法更改<code>data</code>中对象或数组的值保证他们的响应性。</p>
</li>
<li><p>data根级响应式的property不可以动态添加，必须在初始化实例时声明所有的响应式property。主要目的时消除在依赖项跟踪系统中的一类边界情况。同时提高代码的可维护性，<code>data</code>对象就像组件状态的<code>结构(schema)</code></p>
</li>
<li><p>使用Object.freeze()会阻止修改现有的property，响应系统将无法追踪变化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: obj</span><br><span class="line">&#125;)</span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;!-- 这里的 <span class="string">&#x27;foo&#x27;</span> 不会更新 --&gt;</span><br><span class="line">  &lt;button v-on:click=<span class="string">&quot;foo = &#x27;baz&#x27;&quot;</span>&gt;Change it&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h2><p>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。<br><code>Vue,nextTick(callback)</code>回调函数将在DOM更新完成后被调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">Vue.component(<span class="string">&#x27;example&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">&#x27;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&#x27;</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;未更新&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.message = <span class="string">&#x27;已更新&#x27;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;未更新&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;已更新&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 或使用ES2017 async/await</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  updateMessage: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.message = <span class="string">&#x27;已更新&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;未更新&#x27;</span></span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">this</span>.$nextTick()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;已更新&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="过渡效果系统"><a href="#过渡效果系统" class="headerlink" title="过渡效果系统"></a>过渡效果系统</h1><p>Vue插入、更新、移除元素时自动应用过渡效果</p>
<h1 id="Vue将模板编译成虚拟DOM渲染函数"><a href="#Vue将模板编译成虚拟DOM渲染函数" class="headerlink" title="Vue将模板编译成虚拟DOM渲染函数"></a>Vue将模板编译成虚拟DOM渲染函数</h1><h1 id="组件化应用构建"><a href="#组件化应用构建" class="headerlink" title="组件化应用构建"></a>组件化应用构建</h1><p>组件的本质：一个拥有预定义选项的Vue实例<br>大型应用中，将整个应用程序划分为组件，使开发更易管理。</p>
<h2 id="Vue组件与自定义元素（custom-elements）的关系"><a href="#Vue组件与自定义元素（custom-elements）的关系" class="headerlink" title="Vue组件与自定义元素（custom elements）的关系"></a>Vue组件与自定义元素（custom elements）的关系</h2><ul>
<li>自定义元素：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components">web组件（Web Components）规范</a>的一部分</li>
<li>相同点：<ul>
<li>Vue组件语法参考了web组件规范（例如slot API 与 <code>is</code> attribute）</li>
</ul>
</li>
<li>不同点：<ul>
<li>web components规范已通过，但并未被所有浏览器原生实现。然而vue组件不需要任何polyfill，并支持ie9及以上。必要时，Vue组件也可以包装于原生自定义元素之内。</li>
<li>vue组件提供了自定义元素所不具备的一些功能，例如<code>跨组件数据流</code>、<code>自定义事件通信</code>、<code>构建工具集成</code></li>
</ul>
</li>
</ul>
<h1 id="Vue实例生命周期图示"><a href="#Vue实例生命周期图示" class="headerlink" title="Vue实例生命周期图示"></a>Vue实例生命周期图示</h1><p><img src="lifecycle.png"></p>
<h1 id="父子组件单向数据流"><a href="#父子组件单向数据流" class="headerlink" title="父子组件单向数据流"></a>父子组件单向数据流</h1><p>所有的<code>prop</code>使得父子<code>prop</code>之间形成了一个<code>单向下行绑定</code>。以防止子组件意外更改父组件的状态，从而导致应用的数据流向难以理解。</p>
</div></article></div></main><footer><div class="paginator"><a href="/chio.github.io/2021/04/23/frameworksComparison/" class="prev">PREV</a><a href="/chio.github.io/2021/04/20/module-manage/" class="next">NEXT</a></div><div class="copyright"><p>© 2020 - 2021 <a href="https://chiokotomi.github.io/chio.github.io">Chio</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>
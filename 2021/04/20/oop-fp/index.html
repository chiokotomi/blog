<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 面向对象编程与函数式编程 · Chio's Personal Website</title><meta name="description" content="面向对象编程与函数式编程 - Chio"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/chio.github.io/favicon.png"><link rel="stylesheet" href="/chio.github.io/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://chiokotomi.github.io/chio.github.io/atom.xml" title="Chio's Personal Website"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/chio.github.io/atom.xml" title="Chio's Personal Website" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/chio.github.io/" class="logo-link"><img src="/chio.github.io/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/chio.github.io/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/chio.github.io/archives/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="https://weibo.com/u/2001366581" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/chiokotomi" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">面向对象编程与函数式编程</h1><div class="post-info">Apr 20, 2021</div><div class="post-content"><p>OOP与FP是不同的编程风格，了解各自的优缺点结合使用</p>
<span id="more"></span>

<h1 id="面向对象编程object-oriented-programming"><a href="#面向对象编程object-oriented-programming" class="headerlink" title="面向对象编程object oriented programming"></a>面向对象编程object oriented programming</h1><p>把计算机程序视为一组对象的合集，每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间的传递。</p>
<blockquote>
<p>强调<code>状态property</code>与<code>操作method</code>的封装，设计思想：抽象出Class，根据Class创建Instance</p>
</blockquote>
<h2 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h2><ul>
<li>封装：把客观事物封装成抽象的类。保护私有属性与方法</li>
<li>继承：从父类获得属性和方法，实现代码复用</li>
<li>多态：同一事物的多种形态，多个对象有相同的使用方法<ul>
<li>重写overriding：子类有与父类一样的方法名，但是有自己的逻辑，子类与父类的多态性</li>
<li>重载overloading：一个类有多个一样的方法名，但是参数不同，一个类的多态性</li>
</ul>
</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点：易维护、复用、扩展。可设计出低耦合、更灵活的系统。</li>
</ul>
<h2 id="JS实现OOP"><a href="#JS实现OOP" class="headerlink" title="JS实现OOP"></a>JS实现OOP</h2><p>在js中使用OOP有四种方式</p>
<ul>
<li>工场函数</li>
<li>Function constructor构造器函数</li>
<li>Object.create()</li>
<li>ES6 classes</li>
</ul>
<h3 id="工场函数"><a href="#工场函数" class="headerlink" title="工场函数"></a>工场函数</h3><p>创建接收参数返回对象的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personA = &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;lorem&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;ipsum&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">getFullName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Full name is: <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personB = &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;retrum&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;massa&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">getFullName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Full name is: <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person = <span class="function"><span class="keyword">function</span> (<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        firstName,</span><br><span class="line">        lastName,</span><br><span class="line">        <span class="function"><span class="title">getFullName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">`Full name is <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personC = person(<span class="string">&#x27;erat&#x27;</span>, <span class="string">&#x27;luctus&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>如上使用工场函数可以避免代码重复，但是因为每次使用<code>person</code>函数时，<code>getFullName</code>都被重复创建，使用Function constructor方式可以提高内存使用效率。</p>
<h3 id="Function-constructor"><a href="#Function-constructor" class="headerlink" title="Function constructor"></a>Function constructor</h3><p>使用<code>new</code>关键词初始化的函数即为构造器函数，并且最好使用大写首字母</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">    <span class="built_in">this</span>.lastName = lastName</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.getFullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Full name is <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personA = <span class="keyword">new</span> Person(<span class="string">&#x27;lorem&#x27;</span>,<span class="string">&#x27;ipsum&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> personB = <span class="keyword">new</span> Person(<span class="string">&#x27;felis&#x27;</span>,<span class="string">&#x27;ullamcorper&#x27;</span>);</span><br><span class="line"></span><br><span class="line">personA.getFullName();</span><br></pre></td></tr></table></figure>
<p>使用构造器与prototype实现了代码复用，<code>personA</code>与<code>personB</code>两个实例有各自不同的firstName与lastName，但是在原型上有共同的函数<code>getFullName</code>，通过原型链使得构造器函数更高效的利用了内存。</p>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p><code>Object.create()</code>可以使用一个已经存在的对象作为一个新对象的原型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;retrum&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;massa&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">getFullName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Full name is <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personA = <span class="built_in">Object</span>.create(person);</span><br><span class="line">personA.firstName = <span class="string">&#x27;ullam&#x27;</span>;</span><br><span class="line">personA.lastName = <span class="string">&#x27;ipsum&#x27;</span>;</span><br><span class="line">personA.getFullName();</span><br></pre></td></tr></table></figure>
<h3 id="ES6-classes"><a href="#ES6-classes" class="headerlink" title="ES6 classes"></a>ES6 classes</h3><p>es6的class关键词可以创建oop，是一种语法糖本质依旧是原型继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每个实例都不同的属性需要放在constructor里，所有实例共享的方法在外面</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">firstName, lastName</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getFullName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Full name is <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="函数式编程functional-programming"><a href="#函数式编程functional-programming" class="headerlink" title="函数式编程functional programming"></a>函数式编程functional programming</h1><p>所有的程序里两个核心的东西是<strong>数据data</strong>与<strong>行为behavior</strong>。</p>
<p>函数式编程主张数据与行为分离。将代码分成不同的部分，可以保证每一个部分都能被很好的组织。简言之，应该传递数据给函数，函数操作后返回新对象。</p>
<p>一个函数应该满足以下特点：</p>
<ol>
<li>单任务：函数尽量的小执行单一的任务</li>
<li>纯函数：函数不应该有副作用，相同的输入有相同的输出</li>
<li>函数应该有返回<code>return statement</code></li>
<li>函数应该是可组合的<code>compose-able</code></li>
<li>函数应该是不变的<code>immutable</code>：函数应该返回一个数据的copy，而不应该改变原始数据</li>
<li>函数应该是可测的<code>predictable</code></li>
</ol>
<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>保证以下几点的是纯函数</p>
<ul>
<li>1.相同的输入，永远会得到相同的输出，无论函数被执行多少次<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwoNumber</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addTwoNmber(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// will return 7 no matter how many times is called</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyWithCurrentTime</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num * <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">multiplyWithCurrentTime(<span class="number">3</span>);<span class="comment">// will provide new output each time we call the funciton</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>2.计算返回值时不会产生副作用(side effect)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In this example i want to clear out the difference between function with side effect and a function without side effect</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeLastItem</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    input.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">removeLastItem(arr); </span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// output [1,2] (this function changes the orignal variable from [1,2,3] -&gt; [1,2])</span></span><br><span class="line"><span class="comment">// above execution has side effect as it mutate arr which belong to the outside world.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">immutablyRemoveLastItem</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newArray = [].concat(input); <span class="comment">// concat method copies the value to new variable.</span></span><br><span class="line">    <span class="keyword">return</span> newArray.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(immutablyRemoveLastItem(newArr)); <span class="comment">// output [1,2]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// output [1,2,3] -&gt; the above function does not have side effect as it not modify the orignal input instead it copies</span></span><br><span class="line"><span class="comment">// and alter the copied array.</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="引用透明"><a href="#引用透明" class="headerlink" title="引用透明"></a>引用透明</h2><p>一个表达式可以被他的值代替并不会造成其他影响</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function">(<span class="params">num1,num2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b(a(<span class="number">3</span>,<span class="number">4</span>))) <span class="comment">//output will be 14</span></span><br><span class="line"><span class="comment">// here i can replace a(3,4) expression with value 7 value and this will not effect to the result of the program because its return</span></span><br><span class="line"><span class="comment">// value is 7</span></span><br><span class="line"><span class="comment">// so i can replace  console.log(b(a(3,4))) to console.log(b(7)) as a function is refrencially transparent</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="function">(<span class="params">num1,num2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Value of num1:<span class="subst">$&#123;num1&#125;</span> and value of num2:<span class="subst">$&#123;num2&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b(c(<span class="number">3</span>,<span class="number">4</span>))) <span class="comment">//output will be 14</span></span><br><span class="line"><span class="comment">// here i cannot replace expression c(3,4) with value 7 as it effect the result of the program</span></span><br><span class="line"><span class="comment">// function c has console.log() which is one type of side effect so it is not referentially transparent</span></span><br></pre></td></tr></table></figure>
<h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>一个函数相同输入有相同输出，那么函数就是幂等的。不同于纯函数，幂等性允许函数有副作用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非幂等，每次输出都不同</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">notIdempotenceFn</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">notIdempotenceFn(<span class="number">5</span>);</span><br><span class="line">notIdempotenceFn(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 幂等但非纯函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">idempotentFn</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 幂等</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAbsolute</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(x)</span><br><span class="line">&#125;</span><br><span class="line">getAbsolute(getAbsolute(getAbsolute(-<span class="number">50</span>))) <span class="comment">//50</span></span><br></pre></td></tr></table></figure>

<h2 id="命令式vs声明式"><a href="#命令式vs声明式" class="headerlink" title="命令式vs声明式"></a>命令式vs声明式</h2><p>命令式Imperative：告诉做什么、怎么做<br>声明式Declarative：告诉做什么、什么需要被完成</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Imerative命令式</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123; <span class="comment">// 怎么做：定义变量i，直到5向上++</span></span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 做什么：console.log(i)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Declarative声明式</span></span><br><span class="line"><span class="comment">// 做什么：console.log(item)</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].forEach(<span class="function"><span class="params">item</span>=&gt;</span><span class="built_in">console</span>.log(item));</span><br></pre></td></tr></table></figure>
<p>函数式编程通过使用<code>compose</code>让我们更加偏向声明式，<code>compose</code>告诉我们程序要做什么而不是怎么去做</p>
<h2 id="Immutability不变性"><a href="#Immutability不变性" class="headerlink" title="Immutability不变性"></a>Immutability不变性</h2><p>不更改原始状态，而是复制一个新的状态把改变应用到新状态上后返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mutateObj = &#123;</span><br><span class="line">    first_name:<span class="string">&#x27;lorem&#x27;</span>,</span><br><span class="line">    last_name:<span class="string">&#x27;ipsum&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> immutateObj = &#123;</span><br><span class="line">    first_name:<span class="string">&#x27;irum&#x27;</span>,</span><br><span class="line">    last_name:<span class="string">&#x27;egestas&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutatingState = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    obj.first_name = <span class="string">&#x27;ullamcorper&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> immutatingState = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> copiedObj = <span class="built_in">Object</span>.assign(&#123;&#125;,obj);</span><br><span class="line">    copiedObj.first_name = <span class="string">&#x27;facilisis&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> copiedObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutatingState(mutateObj);</span><br><span class="line"><span class="built_in">console</span>.log(mutateObj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">above output &#123;</span></span><br><span class="line"><span class="comment">  first_name:&#x27;ullamcorper&#x27;,</span></span><br><span class="line"><span class="comment">  last_name:&#x27;ipsum&#x27;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">in the above function we have mutated the orignal state</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> newObj = immutatingState(immutateObj);</span><br><span class="line"><span class="built_in">console</span>.log(immutateObj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">newObj will be </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  first_name:&#x27;facilisis&#x27;,</span></span><br><span class="line"><span class="comment">  last_name:&#x27;egestas&#x27;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">and  immutateObj will not be changed and it value is</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  first_name:&#x27;irum&#x27;,</span></span><br><span class="line"><span class="comment">  last_name:&#x27;egestas&#x27;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">here the orignal state is not change</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>函数式编程建议immutability，因为immutability给我们代码带来稳定性与保护性。</p>
<h2 id="高阶函数high-order-function"><a href="#高阶函数high-order-function" class="headerlink" title="高阶函数high order function"></a>高阶函数high order function</h2><p>一个函数接收函数作为参数，或者返回是一个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hocFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">hocFn() <span class="comment">// will return function</span></span><br><span class="line">hocFn()() <span class="comment">// will return 5</span></span><br><span class="line"><span class="comment">// hocFn return function so it is HOC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hocFn2 = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hocFn2(fn); <span class="comment">// will return 10</span></span><br><span class="line"><span class="comment">// hocFn2 accept function as argument it is an HOC</span></span><br></pre></td></tr></table></figure>

<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>柯里化是把一个接收很多参数的函数，转成很多接收一个参数的函数的技巧</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a * b;</span><br><span class="line">multiply(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curring = <span class="function"><span class="params">a</span> =&gt;</span> <span class="function"><span class="params">b</span> =&gt;</span> a * b;</span><br><span class="line">curring(<span class="number">5</span>)(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<h2 id="局部应用"><a href="#局部应用" class="headerlink" title="局部应用"></a>局部应用</h2><p>partially applying a function</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a,b,c</span>) =&gt;</span> a * b * c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Partial Application</span></span><br><span class="line"><span class="keyword">const</span> partiallyMultiplyBy5 = multiply.bind(<span class="literal">null</span>, <span class="number">5</span>); <span class="comment">// 局部应用5作为第一个参数</span></span><br><span class="line">partiallyMultiplyBy5(<span class="number">4</span>, <span class="number">10</span>) <span class="comment">//200  // 此时执行时传入剩余参数</span></span><br></pre></td></tr></table></figure>
<h2 id="记忆化Memoization"><a href="#记忆化Memoization" class="headerlink" title="记忆化Memoization"></a>记忆化Memoization</h2><p>缓存的一种特殊形式</p>
<h2 id="组合compose与管道pipe"><a href="#组合compose与管道pipe" class="headerlink" title="组合compose与管道pipe"></a>组合compose与管道pipe</h2><p><code>组合compose</code>是一种描述函数间关系的设计规则。<code>管道pipe</code>与组合类似，区别在于调用上。组合从右向左执行，管道从左向右执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiplyWith3  = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> getAbsouleOfNum = <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">Math</span>.abs(x);</span><br><span class="line"><span class="comment">// 正常实现给一个值乘3后取模</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">let</span> xAfterMultiply = multiplyWith3(x);</span><br><span class="line"><span class="keyword">let</span> xAfterAbsoulte = getAbsouleOfNum(xAfterMultiply);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过组合的形式：安排两个函数的调用顺序</span></span><br><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> f(g(data));</span><br><span class="line"><span class="keyword">const</span> multiplyBy3andGetAbsolute = compose(multiplyWith3, getAbsouleOfNum);</span><br><span class="line">multiplyBy3andGetAbsolute(-<span class="number">15</span>); <span class="comment">//45</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过管道的形式</span></span><br><span class="line"><span class="keyword">const</span> pipe = <span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> g(f(data));</span><br><span class="line"><span class="keyword">const</span> multiplyBy3andGetAbsolutePipe = pipe(multiplyWith3, getAbsouleOfNum);</span><br><span class="line">multiplyBy3andGetAbsolutePipe(-<span class="number">15</span>);</span><br></pre></td></tr></table></figure>

<h2 id="arity参数数量"><a href="#arity参数数量" class="headerlink" title="arity参数数量"></a>arity参数数量</h2><p>函数化编程建议使用更改少的函数参数（建议1-2个），以让函数更好用。</p>
<h1 id="OOP-vs-FP"><a href="#OOP-vs-FP" class="headerlink" title="OOP vs FP"></a>OOP vs FP</h1><p>OOP强调<code>data</code>与<code>operation</code>的封装，具有封装、继承、多态的主要特点。FP强调<code>data</code>与<code>operation</code>的分离，实现纯函数，避免副作用，通过函数组合实现更强的功能。</p>
<h2 id="共同性"><a href="#共同性" class="headerlink" title="共同性"></a>共同性</h2><p>OOP与FP都是为了让我们的代码更可控的设计模式，代码可控意味着：</p>
<ul>
<li>易读性</li>
<li>易扩展</li>
<li>易维护</li>
<li>内存高效：oop-继承，fp-闭包</li>
<li>DRY（don’t repeat yourself）：避免代码重复<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2></li>
<li>FP 擅于处理在很多操作中修改数据；OOP 擅长处理在少操作中修改共同数据</li>
<li>FP 是无状态的，不会影响程序的其他状态；OOP是有状态的，会改变属性的状态</li>
<li>FP 有无副作用的纯函数；OOP因为修改自己的状态，所有有副作用</li>
<li>FP 是声明式的，专注于该完成什么；OOP是命令式的，专注于如何去做</li>
</ul>
<h2 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h2><ul>
<li>操作多，高性能是用FP</li>
<li>角色对象多操作少的情况用OOP</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/chio.github.io/2021/04/20/module-manage/" class="prev">PREV</a><a href="/chio.github.io/2021/04/14/es5-es6-es7/" class="next">NEXT</a></div><div class="copyright"><p>© 2020 - 2021 <a href="https://chiokotomi.github.io/chio.github.io">Chio</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>
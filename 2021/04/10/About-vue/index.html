<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> vue学习笔记 · Chio's Personal Website</title><meta name="description" content="vue学习笔记 - Chio"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/chio.github.io/favicon.png"><link rel="stylesheet" href="/chio.github.io/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://chiokotomi.github.io/chio.github.io/atom.xml" title="Chio's Personal Website"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/chio.github.io/atom.xml" title="Chio's Personal Website" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/chio.github.io/" class="logo-link"><img src="/chio.github.io/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/chio.github.io/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/chio.github.io/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/2001366581" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/chiokotomi" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">vue学习笔记</h1><div class="post-info">Apr 10, 2021</div><div class="post-content"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul>
<li>vue3 比 vue2 加了什么功能</li>
<li>vue 设计思想，实现了什么功能，怎么实现的</li>
<li>vue 支持到的ie版本</li>
<li>vue 生态其他库的作用是什么</li>
<li>vue3跟typescript关系是什么，好用在哪里</li>
<li>预渲染与服务端渲染如何实现的</li>
</ul>
<h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><h2 id="放弃支持IE11"><a href="#放弃支持IE11" class="headerlink" title="放弃支持IE11"></a>放弃支持IE11</h2><blockquote>
<p>参考vue RFC <a target="_blank" rel="noopener" href="https://github.com/vuejs/rfcs/blob/ie11/active-rfcs/0000-vue3-ie11-support.md">proposal for dropping ie11 support in Vue3</a></p>
</blockquote>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ol>
<li>浏览器和js的环境发生变化，越来越多的开发者开始使用现代语言特性</li>
<li>微软通过投资Edge推动用户停止对IE的使用，同时在自己的<code>Microsoft 365</code>重大项目中放弃使用IE11</li>
<li>WordPress放弃支持IE11</li>
<li>IE11全球使用率跌破1%以下</li>
</ol>
<h3 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h3><h4 id="1-行为不一致"><a href="#1-行为不一致" class="headerlink" title="1. 行为不一致"></a>1. 行为不一致</h4><ul>
<li><p>原因：<code>响应式系统的实现</code>在<code>vue2</code>中基于<code>ES5的getter/setter</code>，在<code>vue3</code>中基于<code>ES2015 Proxies</code>，更高性能更完整的响应式系统。ie11中无法<code>polyfill</code>这些特性。</p>
</li>
<li><p>好处： <code>vue3基于Proxy</code>的响应式系统提供了<code>近乎完整的</code>语言特性覆盖：可以检测到许多在ES5中不可行或不可能的操作，如<code>属性的添加/删除</code>、<code>数组索引和长度突变</code>以及<code>in操作符的检查等功能</code>。</p>
</li>
<li><p>支持方案：使vue3在ie11版本的开发构建中同时发布<code>Proxy</code>和<code>ES5</code>两种响应性版本。</p>
</li>
<li><p>结论： 理论可行，复杂度大，需要将两种实现混合在一起，可能导致<em><strong>开发和生产之间的行为差异</strong></em></p>
</li>
</ul>
<h4 id="2-长期维护负担"><a href="#2-长期维护负担" class="headerlink" title="2. 长期维护负担"></a>2. 长期维护负担</h4><p>支持ie11就必须考虑整个代码库中使用的语言特性与为发布版本找到合适的polyfill编译策略。</p>
<p>每一个不能在ie11中被polyfill的新特性都会带来新的行为警告</p>
<h4 id="3-库作者的复杂性"><a href="#3-库作者的复杂性" class="headerlink" title="3. 库作者的复杂性"></a>3. 库作者的复杂性</h4><p>两个响应性实现也会不可避免的影响vue生态其他库作者开发，若决定支持IE11，在编写库时，需要时刻考虑ES5响应系统的一些缺陷。</p>
<h2 id="新功能"><a href="#新功能" class="headerlink" title="新功能"></a>新功能</h2><ul>
<li>composition API</li>
<li><code>&lt;script setup&gt;</code> 与其他新的<code>单文件组件(SFC)</code>特性</li>
<li>emits 选项</li>
<li>TS 类型改进</li>
<li>Vite官方整合</li>
</ul>
<h1 id="Vue2"><a href="#Vue2" class="headerlink" title="Vue2"></a>Vue2</h1><h3 id="不支持IE8"><a href="#不支持IE8" class="headerlink" title="不支持IE8"></a>不支持IE8</h3><p>实现<code>响应式系统</code>是使用<code>Object.defineProperty</code>来遍历<code>data</code>选项把所有的<code>property</code>转化为<code>getter/setter</code></p>
<p><code>Object.defineProperty</code>是ES5中一个无法shim的特性，这就是Vue2不支持IE8的原因。</p>
<h1 id="版本发布规范"><a href="#版本发布规范" class="headerlink" title="版本发布规范"></a>版本发布规范</h1><blockquote>
<p>遵循<a target="_blank" rel="noopener" href="https://semver.org/lang/zh-CN/">语义化版本控制</a></p>
</blockquote>
<h1 id="VUE设计-非侵入性的响应式系统"><a href="#VUE设计-非侵入性的响应式系统" class="headerlink" title="VUE设计 - 非侵入性的响应式系统"></a>VUE设计 - 非侵入性的响应式系统</h1><blockquote>
<p>响应式系统：修改数据模型(普通的js对象)时，视图会进行更新。这使得状态管理非常简单直接。</p>
</blockquote>
<h2 id="Vue2实现"><a href="#Vue2实现" class="headerlink" title="Vue2实现"></a>Vue2实现</h2><h3 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h3><blockquote>
<p>针对Vue实例的<code>data</code>选项（一般都传入普通的js对象）</p>
</blockquote>
<p>Vue2遍历此对象的所有<code>property</code>，使用<code>Object.defineProperty</code>把所有的<code>property</code>转化为<code>getter/setter</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue2代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">target: <span class="built_in">Object</span>, sourceKey: string, key: string</span>) </span>&#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[sourceKey][key]</span><br><span class="line">  &#125;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[sourceKey][key] = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些<code>getter/setter</code>对用户不可见，在内部可以让Vue能追踪依赖，在property被访问和修改时通知变更。<br>每个组件实例对应一个<code>watcher</code>实例，会在组件渲染的过程中把接触过的数据<code>property</code>记录为依赖，之后当依赖项的<code>setter</code>触发时，会通知<code>watcher</code>，从而使他关联的组件重新渲染。</p>
<p><img src="vue-data-watcher-render.jpg"></p>
<blockquote>
<p>由于js的限制，vue不能检测数组与对象的变化，使用<code>Vue.set/vm.$set</code>方法更改<code>data</code>中对象或数组的值保证他们的响应性。</p>
</blockquote>
<blockquote>
<p>data根级响应式的property不可以动态添加，必须在初始化实例时声明所有的响应式property。主要目的时消除在依赖项跟踪系统中的一类边界情况。同时提高代码的可维护性，<code>data</code>对象就像组件状态的<code>结构(schema)</code></p>
</blockquote>
<h3 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h3><p>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。<br><code>Vue,nextTick(callback)</code>回调函数将在DOM更新完成后被调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">Vue.component(<span class="string">&#x27;example&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">&#x27;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&#x27;</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;未更新&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.message = <span class="string">&#x27;已更新&#x27;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;未更新&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;已更新&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 或使用ES2017 async/await</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  updateMessage: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.message = <span class="string">&#x27;已更新&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;未更新&#x27;</span></span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">this</span>.$nextTick()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;已更新&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Next-To-Learn"><a href="#Next-To-Learn" class="headerlink" title="Next To Learn"></a>Next To Learn</h1><ul>
<li>data 属性设定与作用</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/chio.github.io/2021/04/14/es5-es2015-es6-es7/" class="prev">PREV</a><a href="/chio.github.io/2021/04/09/to-learn-list/" class="next">NEXT</a></div><div class="copyright"><p>© 2020 - 2021 <a href="https://chiokotomi.github.io/chio.github.io">Chio</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>
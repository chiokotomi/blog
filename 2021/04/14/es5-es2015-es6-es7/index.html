<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> es5-es6-es7 · Chio's Personal Website</title><meta name="description" content="es5-es6-es7 - Chio"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/chio.github.io/favicon.png"><link rel="stylesheet" href="/chio.github.io/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://chiokotomi.github.io/chio.github.io/atom.xml" title="Chio's Personal Website"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/chio.github.io/atom.xml" title="Chio's Personal Website" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/chio.github.io/" class="logo-link"><img src="/chio.github.io/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/chio.github.io/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/chio.github.io/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/2001366581" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/chiokotomi" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">es5-es6-es7</h1><div class="post-info">Apr 14, 2021</div><div class="post-content"><h1 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h1><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN doc</a> </p>
<blockquote>
<p>taken from stackoverflow</p>
</blockquote>
<p>Property is an OOP feature designed for clean separation of client code. For example, in some e-shop you might have objects like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name,price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line">  <span class="built_in">this</span>.discount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sneakers = <span class="keyword">new</span> Product(<span class="string">&quot;Sneakers&quot;</span>,<span class="number">20</span>); <span class="comment">// &#123;name:&quot;Sneakers&quot;,price:20,discount:0&#125;</span></span><br><span class="line"><span class="keyword">var</span> tshirt = <span class="keyword">new</span> Product(<span class="string">&quot;T-shirt&quot;</span>,<span class="number">10</span>);  <span class="comment">// &#123;name:&quot;T-shirt&quot;,price:10,discount:0&#125;</span></span><br></pre></td></tr></table></figure>
<p>Then in your client code (the e-shop), you can add discounts to your products:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">badProduct</span>(<span class="params">obj</span>) </span>&#123; obj.discount+= <span class="number">20</span>; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generalDiscount</span>(<span class="params">obj</span>) </span>&#123; obj.discount+= <span class="number">10</span>; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distributorDiscount</span>(<span class="params">obj</span>) </span>&#123; obj.discount+= <span class="number">15</span>; ... &#125;</span><br></pre></td></tr></table></figure>
<p>Later, the e-shop owner might realize that the discount can’t be greater than say 80%. Now you need to find EVERY occurrence of the discount modification in the client code and add a line</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj.discount&gt;<span class="number">80</span>) obj.discount = <span class="number">80</span>;</span><br></pre></td></tr></table></figure>
<p>Then the e-shop owner may further change his strategy, like “if the customer is reseller, the maximal discount can be 90%”. And you need to do the change on multiple places again plus you need to remember to alter these lines anytime the strategy is changed. This is a bad design. That’s why encapsulation is the basic principle of OOP. If the constructor was like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name,price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _name=name, _price=price, _discount=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line">  <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; _name = value; &#125;</span><br><span class="line">  <span class="built_in">this</span>.getPrice = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> _price; &#125;</span><br><span class="line">  <span class="built_in">this</span>.setPrice = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; _price = value; &#125;</span><br><span class="line">  <span class="built_in">this</span>.getDiscount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> _discount; &#125;</span><br><span class="line">  <span class="built_in">this</span>.setDiscount = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; _discount = value; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then you can just alter the getDiscount (accessor) and setDiscount (mutator) methods. The problem is that most of the members behave like common variables, just the discount needs special care here. But good design requires encapsulation of every data member to keep the code extensible. So you need to add lots of code that does nothing. This is also a bad design, a boilerplate antipattern. Sometimes you can’t just refactor the fields to methods later (the eshop code may grow large or some third-party code may depend on the old version), so the boilerplate is lesser evil here. But still, it is evil. That’s why properties were introduced into many languages. You could keep the original code, just transform the discount member into a property with get and set blocks:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name,price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line"><span class="comment">//this.discount = 0; // &lt;- remove this line and refactor with the code below</span></span><br><span class="line">  <span class="keyword">var</span> _discount; <span class="comment">// private member</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>,<span class="string">&quot;discount&quot;</span>,&#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> _discount; &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; _discount = value; <span class="keyword">if</span>(_discount&gt;<span class="number">80</span>) _discount = <span class="number">80</span>; &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the client code</span></span><br><span class="line"><span class="keyword">var</span> sneakers = <span class="keyword">new</span> Product(<span class="string">&quot;Sneakers&quot;</span>,<span class="number">20</span>);</span><br><span class="line">sneakers.discount = <span class="number">50</span>; <span class="comment">// 50, setter is called</span></span><br><span class="line">sneakers.discount+= <span class="number">20</span>; <span class="comment">// 70, setter is called</span></span><br><span class="line">sneakers.discount+= <span class="number">20</span>; <span class="comment">// 80, not 90!</span></span><br><span class="line">alert(sneakers.discount); <span class="comment">// getter is called</span></span><br></pre></td></tr></table></figure>
<p>Note the last but one line: the responsibility for correct discount value was moved from the client code (e-shop definition) to the product definition. The product is responsible for keeping its data members consistent. Good design is (roughly said) if the code works the same way as our thoughts.</p>
<p>So much about properties. But javascript is different from pure Object-oriented languages like C# and codes the features differently:</p>
<p>In C#, transforming fields into properties is a breaking change, so public fields should be coded as Auto-Implemented Properties if your code might be used in the separately compiled client.</p>
<p>In Javascript, the standard properties (data member with getter and setter described above) are defined by accessor descriptor (in the link you have in your question). Exclusively, you can use data descriptor (so you can’t use i.e. value and set on the same property):</p>
<ul>
<li><p>accessor descriptor = get + set (see the example above)</p>
<ul>
<li>get must be a function; its return value is used in reading the property; if not specified, the default is undefined, which behaves like a function that returns undefined</li>
<li>set must be a function; its parameter is filled with RHS in assigning a value to property; if not specified, the default is undefined, which behaves like an empty function</li>
</ul>
</li>
<li><p>data descriptor = value + writable (see the example below)</p>
<ul>
<li>value default undefined; if writable, configurable and enumerable (see below) are true, the property behaves like an ordinary data field</li>
<li>writable - default false; if not true, the property is read only; attempt to write is ignored without error*!<br>Both descriptors can have these members:</li>
</ul>
</li>
<li><p>configurable - default false; if not true, the property can’t be deleted; attempt to delete is ignored without error*!</p>
</li>
<li><p>enumerable - default false; if true, it will be iterated in for(var i in theObject); if false, it will not be iterated, but it is still accessible as public</p>
</li>
</ul>
<ul>
<li>unless in strict mode - in that case JS stops execution with TypeError unless it is caught in try-catch block</li>
</ul>
<p>To read these settings, use Object.getOwnPropertyDescriptor().</p>
<p>Learn by example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&quot;test&quot;</span>,&#123;</span><br><span class="line">  value: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&quot;test&quot;</span>)); <span class="comment">// check the settings    </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> o) <span class="built_in">console</span>.log(o[i]); <span class="comment">// nothing, o.test is not enumerable</span></span><br><span class="line"><span class="built_in">console</span>.log(o.test); <span class="comment">// &quot;a&quot;</span></span><br><span class="line">o.test = <span class="string">&quot;b&quot;</span>; <span class="comment">// o.test is still &quot;a&quot;, (is not writable, no error)</span></span><br><span class="line"><span class="keyword">delete</span>(o.test); <span class="comment">// bye bye, o.test (was configurable)</span></span><br><span class="line">o.test = <span class="string">&quot;b&quot;</span>; <span class="comment">// o.test is &quot;b&quot;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> o) <span class="built_in">console</span>.log(o[i]); <span class="comment">// &quot;b&quot;, default fields are enumerable</span></span><br></pre></td></tr></table></figure>
<p>If you don’t wish to allow the client code such cheats, you can restrict the object by three levels of confinement:</p>
<ul>
<li>Object.preventExtensions(yourObject) prevents new properties to be added to yourObject. Use Object.isExtensible(<yourObject>) to check if the method was used on the object. The prevention is shallow (read below).</li>
<li>Object.seal(yourObject) same as above and properties can not be removed (effectively sets configurable: false to all properties). Use Object.isSealed(<yourObject>) to detect this feature on the object. The seal is shallow (read below).</li>
<li>Object.freeze(yourObject) same as above and properties can not be changed (effectively sets writable: false to all properties with data descriptor). Setter’s writable property is not affected (since it doesn’t have one). The freeze is shallow: it means that if the property is Object, its properties ARE NOT frozen (if you wish to, you should perform something like “deep freeze”, similar to deep copy - cloning). Use Object.isFrozen(<yourObject>) to detect it.</li>
</ul>
<p>You don’t need to bother with this if you write just a few lines fun. But if you want to code a game (as you mentioned in the linked question), you should care about good design. Try to google something about antipatterns and code smell. It will help you to avoid situations like “Oh, I need to completely rewrite my code again!”, it can save you months of despair if you want to code a lot.</p>
</div></article></div></main><footer><div class="paginator"><a href="/chio.github.io/2021/04/20/oop-fp/" class="prev">PREV</a><a href="/chio.github.io/2021/04/10/About-vue/" class="next">NEXT</a></div><div class="copyright"><p>© 2020 - 2021 <a href="https://chiokotomi.github.io/chio.github.io">Chio</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>
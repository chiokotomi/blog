<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chio&#39;s Personal Website</title>
  
  
  <link href="https://chiokotomi.github.io/chio.github.io/atom.xml" rel="self"/>
  
  <link href="https://chiokotomi.github.io/chio.github.io/"/>
  <updated>2021-05-12T12:10:37.694Z</updated>
  <id>https://chiokotomi.github.io/chio.github.io/</id>
  
  <author>
    <name>Chio</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>react规模</title>
    <link href="https://chiokotomi.github.io/chio.github.io/2021/05/12/react%E8%A7%84%E6%A8%A1/"/>
    <id>https://chiokotomi.github.io/chio.github.io/2021/05/12/react%E8%A7%84%E6%A8%A1/</id>
    <published>2021-05-12T03:53:01.000Z</published>
    <updated>2021-05-12T12:10:37.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="props-amp-state-amp-生命周期"><a href="#props-amp-state-amp-生命周期" class="headerlink" title="props &amp; state &amp; 生命周期"></a>props &amp; state &amp; 生命周期</h2><h3 id="props：由父组件传入，固定的数据，子组件不可修改"><a href="#props：由父组件传入，固定的数据，子组件不可修改" class="headerlink" title="props：由父组件传入，固定的数据，子组件不可修改"></a>props：由父组件传入，固定的数据，子组件不可修改</h3><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>组件内维护的动态数据，使ui具备交互功能</p><ul><li>检查相应数据是否属于 state：<ul><li>该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。</li><li>该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。</li><li>你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 不写constructor就没有state</span></span><br><span class="line"> <span class="comment">// 写了constructor一定要super，否贼thhis不会指向组件自己</span></span><br><span class="line"> <span class="comment">// 当想在constructor中使用this.props的时候，super需要加入(props)</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>更新state<br>直接修改<code>this.state.xxx = &#39;xxx&#39;</code>不会重新渲染组件，使用<code>this.setState(&#123;xxx: &#39;xxx&#39;&#125;)</code>才会触发渲染<br>state的更新可能是异步的</li></ul><h3 id="生命周期：componentWillUnmount、componentDidMount"><a href="#生命周期：componentWillUnmount、componentDidMount" class="headerlink" title="生命周期：componentWillUnmount、componentDidMount"></a>生命周期：<code>componentWillUnmount</code>、<code>componentDidMount</code></h3><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>在兄弟节点之间必须唯一</p><h2 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h2><p>多个组件共享的state向上移动到父组件，数据源唯一，自上而下的数据流</p><h2 id="组合-vs-继承"><a href="#组合-vs-继承" class="headerlink" title="组合 vs 继承"></a>组合 vs 继承</h2><blockquote><p>推荐使用组合来实现组件间的代码复用</p></blockquote><h1 id="代码分割-与-懒加载"><a href="#代码分割-与-懒加载" class="headerlink" title="代码分割 与 懒加载"></a>代码分割 与 懒加载</h1><p>当 Webpack 解析到该语法时，会自动进行代码分割</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">16</span>, <span class="number">26</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码分割</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&quot;./math&quot;</span>).then(<span class="function"><span class="params">math</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(math.add(<span class="number">16</span>, <span class="number">26</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>React.lazy()</code>与<code>Suspense</code>组件实现懒加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Suspense &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./OtherComponent&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> AnotherComponent = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./AnotherComponent&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;&gt;</span><br><span class="line">        &lt;section&gt;</span><br><span class="line">          &lt;OtherComponent /&gt;</span><br><span class="line">          &lt;AnotherComponent /&gt;</span><br><span class="line">        &lt;/section&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="diffing算法"><a href="#diffing算法" class="headerlink" title="diffing算法"></a>diffing算法</h1><h1 id="高阶组件-HOC"><a href="#高阶组件-HOC" class="headerlink" title="高阶组件 HOC"></a>高阶组件 HOC</h1><p>复用组件逻辑的一种高级技巧，是基于React组合特性而形成的设计模式<br>高阶组件是<code>参数为组件</code>，<code>返回值为新组件</code>的<code>函数</code><br>HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作用</p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><p>React 只更新改变了的 DOM 节点，重新渲染仍然花费了一些时间。可以通过覆盖生命周期方法 shouldComponentUpdate 来进行提速。该方法会在重新渲染前被触发。其默认实现总是返回 true，让 React 执行更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./should-component-update.png"><br>组件只有当 props.color 或者 state.count 的值改变才需要更新时，你可以使用 shouldComponentUpdate 来进行检查：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">count</span>: <span class="number">1</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.props.color !== nextProps.color) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state.count !== nextState.count) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button</span><br><span class="line">        color=&#123;<span class="built_in">this</span>.props.color&#125;</span><br><span class="line">        onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;))&#125;&gt;</span><br><span class="line">        Count: &#123;<span class="built_in">this</span>.state.count&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 已经提供了一位好帮手来帮你实现这种常见的模式 - 你只要继承 React.PureComponent 就行了。所以这段代码可以改成以下这种更简洁的形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">count</span>: <span class="number">1</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button</span><br><span class="line">        color=&#123;<span class="built_in">this</span>.props.color&#125;</span><br><span class="line">        onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;))&#125;&gt;</span><br><span class="line">        Count: &#123;<span class="built_in">this</span>.state.count&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Profiler组件测量渲染带来的开销"><a href="#Profiler组件测量渲染带来的开销" class="headerlink" title="Profiler组件测量渲染带来的开销"></a>Profiler组件测量渲染带来的开销</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">render(</span><br><span class="line">  &lt;App&gt;</span><br><span class="line">    &lt;Profiler id=<span class="string">&quot;Navigation&quot;</span> onRender=&#123;callback&#125;&gt;</span><br><span class="line">      &lt;Navigation &#123;...props&#125; /&gt;</span><br><span class="line">    &lt;/Profiler&gt;</span><br><span class="line">    &lt;Main &#123;...props&#125; /&gt;</span><br><span class="line">  &lt;/App&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRenderCallback</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  id, <span class="comment">// 发生提交的 Profiler 树的 “id”</span></span></span></span><br><span class="line"><span class="function"><span class="params">  phase, <span class="comment">// &quot;mount&quot; （如果组件树刚加载） 或者 &quot;update&quot; （如果它重渲染了）之一</span></span></span></span><br><span class="line"><span class="function"><span class="params">  actualDuration, <span class="comment">// 本次更新 committed 花费的渲染时间</span></span></span></span><br><span class="line"><span class="function"><span class="params">  baseDuration, <span class="comment">// 估计不使用 memoization 的情况下渲染整颗子树需要的时间</span></span></span></span><br><span class="line"><span class="function"><span class="params">  startTime, <span class="comment">// 本次更新中 React 开始渲染的时间</span></span></span></span><br><span class="line"><span class="function"><span class="params">  commitTime, <span class="comment">// 本次更新中 React committed 的时间</span></span></span></span><br><span class="line"><span class="function"><span class="params">  interactions <span class="comment">// 属于本次更新的 interactions 的集合</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 合计或记录渲染时间。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h1><h2 id="package管理器"><a href="#package管理器" class="headerlink" title="package管理器"></a>package管理器</h2><p>npm / yarn</p><h2 id="打包器"><a href="#打包器" class="headerlink" title="打包器"></a>打包器</h2><p>webpack </p><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>babel</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;核心概念&quot;&gt;&lt;a href=&quot;#核心概念&quot; class=&quot;headerlink&quot; title=&quot;核心概念&quot;&gt;&lt;/a&gt;核心概念&lt;/h1&gt;&lt;h2 id=&quot;props-amp-state-amp-生命周期&quot;&gt;&lt;a href=&quot;#props-amp-state-amp-生</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JS语言基础一</title>
    <link href="https://chiokotomi.github.io/chio.github.io/2021/05/08/prototype/"/>
    <id>https://chiokotomi.github.io/chio.github.io/2021/05/08/prototype/</id>
    <published>2021-05-08T05:49:08.000Z</published>
    <updated>2021-05-10T13:25:43.427Z</updated>
    
    <content type="html"><![CDATA[<p>了解关于<strong>作用域 &amp; 闭包 &amp; 原型继承</strong>基本原理</p><span id="more"></span><h1 id="作用域scope"><a href="#作用域scope" class="headerlink" title="作用域scope"></a>作用域scope</h1><p>作用域决定了代码区块中变量和其他资源的可见性。作用域最大的用处是隔离变量，不同作用域下同名变量不会冲突。</p><p>ES6之前JS只有<code>全局作用域</code>和<code>函数作用域</code>,ES6之后有了<code>块级作用域</code></p><h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><p>代码中任何地方都能访问的对象有全局作用域</p><ul><li>最外层函数和最外层函数外面定义的变量<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outVariable = <span class="string">&#x27;最外层变量&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outFun</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 最外层函数</span></span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>未定义直接赋值的变量自动声明拥有全局作用域<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    variable = <span class="string">&#x27;未定义直接赋值的变量&#x27;</span>; <span class="comment">// 全局</span></span><br><span class="line">    <span class="keyword">var</span> inVariable2 = <span class="string">&#x27;内层变量&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>所有window对象的属性拥有全局作用域</li></ul><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>声明在函数内部的变量拥有局部作用域，这样函数里面的变量不会外泄暴露，不会污染到外面，例如jquery,zepto等库源码代码会放在<code>(function()&#123;&#125;)()</code>中。</p><blockquote><p>作用域是分层的，内层作用域可以访问外层作用域的变量，反之不行。</p></blockquote><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><blockquote><p>大括号<code>&#123;&#125;</code>中间的语句是块语句，如<code>if switch for while</code></p></blockquote><p>块级作用域可以通过新增命令<code>let/const</code>声明，所声明变量在指定块的作用域外无法访问，声明变量不会提升到当前代码块的顶部，禁止重复声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// value在此处不可用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环的块级作用域最为必要，常见情况</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>测试1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>测试2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>测试3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> btns = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// var定义的i是全局变量，执行到点击事件时i为3，点击任意按钮都弹出“第4个”</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">        btns[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;第&#x27;</span> + (i + <span class="number">1</span>) + <span class="string">&#x27;个&#x27;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="comment">// let声明i是块级作用域</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">        btns[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;第&#x27;</span> + (i + <span class="number">1</span>) + <span class="string">&#x27;个&#x27;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>一层一层寻找变量取值的关系就是作用域链</p><h2 id="静态作用域"><a href="#静态作用域" class="headerlink" title="静态作用域"></a>静态作用域</h2><p>如何寻找变量的取值：要到创建函数的作用域中找，即为静态作用域<code>static scope/ lexical scope</code></p><p>可用的变量取决于静态作用域（函数定义的位置），而不是函数调用的位置（动态作用域）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">20</span>; <span class="comment">// b取值为fn函数作用域20，最终输出结果为30</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a + b); <span class="comment">//30</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = fn(),</span><br><span class="line">    b = <span class="number">200</span>;</span><br><span class="line">x(); <span class="comment">//bar()</span></span><br></pre></td></tr></table></figure><h2 id="作用域与执行上下文"><a href="#作用域与执行上下文" class="headerlink" title="作用域与执行上下文"></a>作用域与执行上下文</h2><blockquote><p>作用域在定义时就确定，且不会改变；执行上下文(execution context)在运行时确定，随时可能改变</p></blockquote><p>js属于解释型语言，js的执行分为<code>解释</code>和<code>执行</code>两个阶段</p><ul><li>解释阶段：词法环境定义在代码所在位置，每一个执行上下文有他自己的词法环境<ul><li>词法分析</li><li>语法分析</li><li>作用域规则确定</li></ul></li><li>执行阶段<ul><li>创建执行上下文：代码执行时，js引擎提供一个全局执行上下文，执行函数时会创建一个新的函数执行上下文。所有在代码里的变量都在内存堆中有内存位置，变量环境<code>variable environment</code>决定哪个变量被附在执行上下文中。</li><li>执行函数代码</li><li>垃圾回收</li></ul></li></ul><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包的存在基于两点："><a href="#闭包的存在基于两点：" class="headerlink" title="闭包的存在基于两点："></a>闭包的存在基于两点：</h2><ul><li>1.<code>Function</code>是js里的第一公民<code>first-class citizen</code></li></ul><blockquote><p>第一公民支持所有操作包括：作为函数参数、函数返回值、直接赋值给变量</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数表达式，即将函数赋值给一个变量</span></span><br><span class="line"><span class="keyword">const</span> funcSing = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span> sings: La la lalala`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 函数作为参数 </span></span><br><span class="line"><span class="keyword">const</span> letPerson = <span class="function">(<span class="params">name, fn</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(name);</span><br><span class="line">&#125;;</span><br><span class="line">letPerson(<span class="string">&#x27;Peter&#x27;</span>, funcSing);</span><br><span class="line"><span class="comment">// 函数作为返回值</span></span><br><span class="line"><span class="keyword">const</span> myName = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> whatsMyName = myName(<span class="string">&#x27;Peter&#x27;</span>); <span class="comment">// 返回一个函数</span></span><br><span class="line">whatsMyName();</span><br></pre></td></tr></table></figure><ul><li>2.js有词法作用域（或静态作用域）<code>lexical scope/static scope</code></li></ul><h2 id="创建闭包"><a href="#创建闭包" class="headerlink" title="创建闭包"></a>创建闭包</h2><p>函数可以使用其父函数内的变量，一个函数返回了一个函数后，其内部的局部变量还被新函数引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> outer = <span class="string">&#x27;外部函数变量&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">innerFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(outer);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">outerFun()();</span><br></pre></td></tr></table></figure><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><ul><li>1.高效使用内存</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有闭包时每一次调用函数都需要重新开辟array</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withOutClosure</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">8000</span>).fill(<span class="string">&#x27;lorem ipsum olorem&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> arr[index];</span><br><span class="line">&#125;</span><br><span class="line">withOutClosure(<span class="number">543</span>);</span><br><span class="line">withOutClosure(<span class="number">654</span>);</span><br><span class="line">withOutClosure(<span class="number">345</span>);</span><br><span class="line">withOutClosure(<span class="number">135</span>);</span><br><span class="line"><span class="comment">// 有闭包时，每次调用函数都使用的是同一个array</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withClosure</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">8000</span>).fill(<span class="string">&#x27;lorem ipsum olorem&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> findFromIndex = withClosure();</span><br><span class="line">findFromIndex(<span class="number">20</span>);</span><br><span class="line">findFromIndex(<span class="number">290</span>);</span><br><span class="line">findFromIndex(<span class="number">4567</span>);</span><br></pre></td></tr></table></figure><ul><li>2.实现封装</li></ul><p>封装可以保护内部私有数据不泄露，不被外面使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encapEg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> protectedData = <span class="number">0</span>; <span class="comment">// this is the protected data that we only want to allow read access not direct change it</span></span><br><span class="line">    <span class="keyword">const</span> accessTheData = <span class="function">() =&gt;</span> protectedData; <span class="comment">// this function will exported</span></span><br><span class="line">    <span class="keyword">const</span> updateData = <span class="function">()=&gt;</span> protectedData++; <span class="comment">// we want to update the protected data internall</span></span><br><span class="line">    <span class="built_in">setInterval</span>(updateData,<span class="number">1000</span>); <span class="comment">//this is the logic to update the data</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        accessTheData <span class="comment">// we return the function that only allow to access the protected data</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = encapEg();</span><br><span class="line"><span class="built_in">console</span>.log(obj.accessTheData());</span><br></pre></td></tr></table></figure><h1 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h1><p><img src="1.png"><br>变量<code>a</code>没有<code>concat</code>方法，从原型继承了<code>concat</code>方法，<code>a.__proto__</code>属性指向<code>Array</code></p><ul><li>原型链</li></ul><p><img src="2.png"><br><code>a.toString()</code>方法不是变量<code>a</code>的方法，于是js引擎查找<code>a.__proto__</code>即<code>Array.prototype</code>，<code>Array</code>也没有该方法，于是继续查找<code>a.__proto__.__proto__</code>直到最后返回。</p><p><img src="3.png"></p><ul><li>检查属性是否属于对象本身而非其原型链中：<code>hasOwnProperty</code></li></ul><p><img src="4.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;了解关于&lt;strong&gt;作用域 &amp;amp; 闭包 &amp;amp; 原型继承&lt;/strong&gt;基本原理&lt;/p&gt;</summary>
    
    
    
    
    <category term="prototype" scheme="https://chiokotomi.github.io/chio.github.io/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>Web Components</title>
    <link href="https://chiokotomi.github.io/chio.github.io/2021/04/26/webComponents/"/>
    <id>https://chiokotomi.github.io/chio.github.io/2021/04/26/webComponents/</id>
    <published>2021-04-26T04:01:18.000Z</published>
    <updated>2021-05-10T13:26:17.073Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Web Components</strong> 可以创建可复用的定制元素，包含三项主要技术。</p><span id="more"></span><ol><li><strong>Custom elements （自定义元素）：</strong>JS API，可以定义custom elements及其行为，在用户界面中按需求使用。</li><li><strong>Shadow DOM （影子DOM）：</strong>JS API，用于将封装的影子DOM树附加到元素（与主文档DOM分开呈现）并控制其关联功能。这样可以保持元素的功能私有，可以被脚本化和样式化，不会与文档的其他部分发生冲突。</li><li><strong>HTML templates（HTML模板）：</strong> <code>&lt;template&gt;</code>和<code>&lt;slot&gt;</code>元素可以编写不在页面中显示的标记模板，然后他们可以作为自定义元素结构的基础被多次复用。</li></ol><blockquote><p>FF63+、Chrome、Opera支持，Safari支持部分web组件特性，Edge正在开发一个实现，ie不支持</p></blockquote><h1 id="Custom-elements"><a href="#Custom-elements" class="headerlink" title="Custom elements"></a>Custom elements</h1><p>共有两种custom elements</p><ul><li>Autonomous custom elements： 是独立元素，不继承自其他内建的HTML元素。可以直接写成HTML标签的形式，在页面上使用。例如<code>&lt;popup-info&gt;</code>或者是<code>document.createElement(&quot;popup-info&quot;)</code></li><li>Customized built-in elements： 继承自基本的HTML元素。在创建时，必须指定所需扩展的元素。使用时，需要先写出基本的元素标签，通过<code>is</code>属性指定custom element的名称。例如<code>&lt;p is=&quot;word-count&quot;&gt;</code>或者<code>document.createElement(&quot;p&quot;, &#123;is: &quot;word-count&quot;&#125;)</code>。</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>注册一个custom element使用<code>CustomElementRegistry.define()</code>，接收三个参数：</p><ul><li>元素名称，符合<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString">DOMString</a>标准的字符串，必须包含短横线。</li><li>用于定义元素行为的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">类</a></li><li><code>可选参数</code>：一个包含<code>extends</code>属性的配置对象，指定所创建的元素继承自哪个内置元素。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Autonomous custom element</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PopUpInfo</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">customElements.define(<span class="string">&#x27;popup-info&#x27;</span>, PopUpInfo);</span><br><span class="line"></span><br><span class="line">&lt;popup-info img=<span class="string">&quot;img/alt.png&quot;</span> text=<span class="string">&quot;some info&quot;</span>&gt;&lt;/popup-info&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Customized built-in element</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpandingList</span> <span class="keyword">extends</span> <span class="title">HTMLUListElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customElements.define(<span class="string">&#x27;expanding-list&#x27;</span>, ExpandingList, &#123;<span class="attr">extends</span>: <span class="string">&#x27;ul&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">&lt;ul is=<span class="string">&quot;expanding-list&quot;</span>&gt;&lt;/ul&gt;</span><br></pre></td></tr></table></figure><h2 id="声命周期回调函数"><a href="#声命周期回调函数" class="headerlink" title="声命周期回调函数"></a>声命周期回调函数</h2><p>在custom element的构造函数中，可以指定多个不同的回调函数，在元素的不同生命时期被调用：</p><ul><li><code>connectedCallback</code>: 首次被插入文档DOM时，被调用</li><li><code>disconnectedCallback</code>： 从文档DOM中删除时，被调用</li><li><code>adoptedCallback</code>： 被移动到新的文档时，被调用</li><li><code>attributeChangedCallback</code>： 增加、删除、修改自身属性时，被调用</li></ul><h1 id="shadow-DOM"><a href="#shadow-DOM" class="headerlink" title="shadow DOM"></a>shadow DOM</h1><p>Shadow DOM可以将一个隐藏的、独立的DOM附加到常规的DOM树中。它以shadow root节点为起始根节点，在根节点的下方，可以是任意元素，和普通的DOM元素一样。</p><p><img src="shadow-dom.png"></p><ul><li><strong>Shadow host:</strong> 一个常规的DOM节点，Shadow DOM会被附加到这个节点上</li><li><strong>Shadow tree:</strong> Shadow DOM内部的DOM树</li><li><strong>Shadow boundary:</strong> Shadow DOM结束的地方，也是常规DOM开始的地方</li><li><strong>Shadow root:</strong> Shadow tree根节点</li></ul><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><code>Element.attachShadow(&#123;mode: &#39;open&#39;|&#39;closed&#39; &#125;)</code>将一个shadow root附加到任何一个元素上。<br><code>open</code>表示可以通过页面内的js方法来获取Shadow DOM，如<code>Element.shadowRoot</code><br><code>closed</code>不可以从外部获取Shadow DOM，如浏览器内置元素如<code>&lt;video&gt;&lt;/video&gt;</code></p><blockquote><p>常规<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction">DOM（文档对象模型）</a></p></blockquote><h1 id="templates-and-slots"><a href="#templates-and-slots" class="headerlink" title="templates and slots"></a>templates and slots</h1><h2 id="templates"><a href="#templates" class="headerlink" title="templates"></a>templates</h2><p>模板可以复用相同的结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=<span class="string">&quot;my-paragraph&quot;</span>&gt;</span><br><span class="line">    &lt;p&gt;My paragraph&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>上面代码不会出现在页面中，直到使用js获取它的引用，然后添加到DOM中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> template = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;my-paragraph&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> templateContent = template.content;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(templateContent);</span><br></pre></td></tr></table></figure><h2 id="slots"><a href="#slots" class="headerlink" title="slots"></a>slots</h2><p>插槽能在单个实例中通过声明式的语法展示不同的文本。<br>slots由<code>name</code>属性标识，并且在模板中定义占位符。在实例中使用slot标记时，占位符可以填充为所需的任何HTML标记片段。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;&lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;template id=<span class="string">&quot;my-paragraph&quot;</span>&gt;</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">                &lt;slot name=<span class="string">&quot;my-text&quot;</span>&gt;</span><br><span class="line">                    My <span class="keyword">default</span> text</span><br><span class="line">                &lt;/slot&gt;</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">        &lt;my-paragraph&gt;</span><br><span class="line">            &lt;span slot=<span class="string">&quot;my-text&quot;</span>&gt;Let<span class="string">&#x27;s have some different text&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/my-paragraph&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &lt;my-paragraph&gt;</span></span><br><span class="line"><span class="string">            &lt;ul slot=&quot;my-text&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;li&gt;list 1&lt;/li&gt;</span></span><br><span class="line"><span class="string">                &lt;li&gt;list 2&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;/ul&gt;</span></span><br><span class="line"><span class="string">        &lt;/my-paragraph&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Web Components&lt;/strong&gt; 可以创建可复用的定制元素，包含三项主要技术。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>主流框架对比</title>
    <link href="https://chiokotomi.github.io/chio.github.io/2021/04/23/frameworksComparison/"/>
    <id>https://chiokotomi.github.io/chio.github.io/2021/04/23/frameworksComparison/</id>
    <published>2021-04-23T12:13:47.000Z</published>
    <updated>2021-05-12T03:48:40.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-vs-Vue"><a href="#React-vs-Vue" class="headerlink" title="React vs Vue"></a>React vs Vue</h1><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><ul><li>react：从开发模式上提出突破性的新方向，ui开发的新思路，rethinking best pratices</li><li>vue：降低开发门槛，快速上手开发<h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2></li><li>使用虚拟Dom（Virtual Dom）：代码操作虚拟dom比操作真实dom效率更高渲染效率更快</li><li>提供响应式（Reactive）和组件化（Composable）的视图组件：数据驱动UI变化，原子组件组成世界的概念</li><li>将注意力集中保持在核心库，而将其他功能（路由、全局状态管理）交给相关库。</li></ul><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><h3 id="运行时性能优化"><a href="#运行时性能优化" class="headerlink" title="运行时性能优化"></a>运行时性能优化</h3><ul><li>React<br>当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。<br>避免不必要的子组件重渲染，需要尽可能使用<code>PureComponent</code>，或是手动实现<code>shouldComponentUpdate</code></li><li>Vue<br>组件的依赖在渲染过程中自动追踪，不需要开发者自己考虑此类优化。<h3 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML &amp; CSS"></a>HTML &amp; CSS</h3></li><li>React<br>一切都是jsx：可以使用js来构建视图页面，开发工具(linting、类型检查等)支持更先进</li><li>vue<br>推荐模板：更符合HTML开发习惯</li></ul><h3 id="规模"><a href="#规模" class="headerlink" title="规模"></a>规模</h3><ul><li>React<br>把路由库与状态库交给社区维护，创建一个更分散的生态系统，相对更繁荣。</li><li>Vue<br>路由跟状态库由官方支持维护与核心库同步更新。<br>提供功能更全的CLI脚手架</li></ul><h3 id="原生渲染"><a href="#原生渲染" class="headerlink" title="原生渲染"></a>原生渲染</h3><ul><li>React<br>React Native 使用相同的组件模型编写有本地渲染能力的APP，可以跨多平台</li><li>Vue<br>Weex与阿里合作，发起跨多平台用户界面开发框架</li></ul><h1 id="Vue-vs-Angular1"><a href="#Vue-vs-Angular1" class="headerlink" title="Vue vs Angular1"></a>Vue vs Angular1</h1><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><ul><li>Angular1 双向绑定</li><li>Vue 单向数据流，数据流向更清晰<h2 id="指令与组件"><a href="#指令与组件" class="headerlink" title="指令与组件"></a>指令与组件</h2></li><li>Angular1 所有都是指令，组件是特殊的指令</li><li>vue 指令跟组件区分清晰，指令只封装dom操作，组件代表一个独立单元有自己的数据逻辑与视图</li></ul><h2 id="运行时性能"><a href="#运行时性能" class="headerlink" title="运行时性能"></a>运行时性能</h2><ul><li>Angular1 使用watcher，越多越慢，使用脏检查循环(digest cycle)</li><li>vue 基于依赖追踪观察系统，并且异步队列更新，数据变化独立触发没有明确依赖</li></ul><h1 id="Vue-vs-Angular2"><a href="#Vue-vs-Angular2" class="headerlink" title="Vue vs Angular2"></a>Vue vs Angular2</h1><ul><li>Angular2<br>必须要用ts开发<br>使用tree-shaking后体积依旧比vue规模大很多</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React-vs-Vue&quot;&gt;&lt;a href=&quot;#React-vs-Vue&quot; class=&quot;headerlink&quot; title=&quot;React vs Vue&quot;&gt;&lt;/a&gt;React vs Vue&lt;/h1&gt;&lt;h2 id=&quot;定位&quot;&gt;&lt;a href=&quot;#定位&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue2与规模化</title>
    <link href="https://chiokotomi.github.io/chio.github.io/2021/04/22/vue2/"/>
    <id>https://chiokotomi.github.io/chio.github.io/2021/04/22/vue2/</id>
    <published>2021-04-22T13:24:52.000Z</published>
    <updated>2021-05-12T03:21:33.596Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Vue是一个用于构建用户界面的渐进式框架</strong>，对于已存在的服务端应用，可将vue作为应用的一部分嵌入；如果将更多的业务逻辑放在前端，也可以用vue的核心库与生态系统来实现。</p><span id="more"></span><p>Vue核心库只关注视图层。</p><h1 id="安装介绍"><a href="#安装介绍" class="headerlink" title="安装介绍"></a>安装介绍</h1><h2 id="不支持IE8"><a href="#不支持IE8" class="headerlink" title="不支持IE8"></a>不支持IE8</h2><p>实现<code>响应式系统</code>是使用<code>Object.defineProperty</code>来遍历<code>data</code>选项把所有的<code>property</code>转化为<code>getter/setter</code></p><p><code>Object.defineProperty</code>是ES5中一个无法shim的特性，这就是Vue2不支持IE8的原因。</p><h2 id="版本发布遵循语义化版本控制"><a href="#版本发布遵循语义化版本控制" class="headerlink" title="版本发布遵循语义化版本控制"></a>版本发布遵循语义化版本控制</h2><p>遵循<a href="https://semver.org/lang/zh-CN/">语义化版本控制</a></p><h2 id="构建版本"><a href="#构建版本" class="headerlink" title="构建版本"></a>构建版本</h2><ul><li>编译器： 用来将模板字符串编译成为JavaScript渲染函数的代码<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要编译器</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    template: <span class="string">&#x27;&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>运行时： 用来创建Vue实例、渲染并处理虚拟DOM等的代码。基本上就是除去编译器的其他一切。<strong>运行时版本比完整版体积小大约30%</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要编译器</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    render (h) &#123;</span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">this</span>.hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>完整版： 编译器+运行时</li></ul><h1 id="非侵入性的响应式系统"><a href="#非侵入性的响应式系统" class="headerlink" title="非侵入性的响应式系统"></a>非侵入性的响应式系统</h1><p><strong>响应式系统：</strong>修改数据模型(普通的js对象)时，视图会进行更新。这使得状态管理非常简单直接。</p><h2 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h2><blockquote><p>针对Vue实例的<code>data</code>选项（一般都传入普通的js对象）</p></blockquote><p>Vue2遍历此对象的所有<code>property</code>，使用<code>Object.defineProperty</code>把所有的<code>property</code>转化为<code>getter/setter</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue2代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">target: <span class="built_in">Object</span>, sourceKey: string, key: string</span>) </span>&#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[sourceKey][key]</span><br><span class="line">  &#125;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[sourceKey][key] = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些<code>getter/setter</code>对用户不可见，在内部可以让Vue能追踪依赖，在property被访问和修改时通知变更。<br>每个组件实例对应一个<code>watcher</code>实例，会在组件渲染的过程中把接触过的数据<code>property</code>记录为依赖，之后当依赖项的<code>setter</code>触发时，会通知<code>watcher</code>，从而使他关联的组件重新渲染。</p><p><img src="vue-data-watcher-render.jpg"></p><p>需要注意的事：</p><ul><li><p>由于js的限制，vue不能检测数组与对象的变化，使用<code>Vue.set/vm.$set</code>方法更改<code>data</code>中对象或数组的值保证他们的响应性。</p></li><li><p>data根级响应式的property不可以动态添加，必须在初始化实例时声明所有的响应式property。主要目的时消除在依赖项跟踪系统中的一类边界情况。同时提高代码的可维护性，<code>data</code>对象就像组件状态的<code>结构(schema)</code></p></li><li><p>使用Object.freeze()会阻止修改现有的property，响应系统将无法追踪变化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: obj</span><br><span class="line">&#125;)</span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;!-- 这里的 <span class="string">&#x27;foo&#x27;</span> 不会更新 --&gt;</span><br><span class="line">  &lt;button v-on:click=<span class="string">&quot;foo = &#x27;baz&#x27;&quot;</span>&gt;Change it&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h2><p>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。<br><code>Vue,nextTick(callback)</code>回调函数将在DOM更新完成后被调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">Vue.component(<span class="string">&#x27;example&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">&#x27;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&#x27;</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;未更新&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.message = <span class="string">&#x27;已更新&#x27;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;未更新&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;已更新&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 或使用ES2017 async/await</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  updateMessage: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.message = <span class="string">&#x27;已更新&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;未更新&#x27;</span></span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">this</span>.$nextTick()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;已更新&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Vue将模板编译成虚拟DOM渲染函数"><a href="#Vue将模板编译成虚拟DOM渲染函数" class="headerlink" title="Vue将模板编译成虚拟DOM渲染函数"></a>Vue将模板编译成虚拟DOM渲染函数</h1><h1 id="组件化应用构建"><a href="#组件化应用构建" class="headerlink" title="组件化应用构建"></a>组件化应用构建</h1><p>组件的本质：一个拥有预定义选项的Vue实例<br>大型应用中，将整个应用程序划分为组件，使开发更易管理。</p><h2 id="Vue组件与自定义元素（custom-elements）的关系"><a href="#Vue组件与自定义元素（custom-elements）的关系" class="headerlink" title="Vue组件与自定义元素（custom elements）的关系"></a>Vue组件与自定义元素（custom elements）的关系</h2><ul><li>自定义元素：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components">web组件（Web Components）规范</a>的一部分</li><li>相同点：<ul><li>Vue组件语法参考了web组件规范（例如slot API 与 <code>is</code> attribute）</li></ul></li><li>不同点：<ul><li>web components规范已通过，但并未被所有浏览器原生实现。然而vue组件不需要任何polyfill，并支持ie9及以上。必要时，Vue组件也可以包装于原生自定义元素之内。</li><li>vue组件提供了自定义元素所不具备的一些功能，例如<code>跨组件数据流</code>、<code>自定义事件通信</code>、<code>构建工具集成</code></li></ul></li></ul><h2 id="Vue实例生命周期图示"><a href="#Vue实例生命周期图示" class="headerlink" title="Vue实例生命周期图示"></a>Vue实例生命周期图示</h2><p><img src="lifecycle.png"></p><h2 id="父子组件单向数据流"><a href="#父子组件单向数据流" class="headerlink" title="父子组件单向数据流"></a>父子组件单向数据流</h2><p>所有的<code>prop</code>使得父子<code>prop</code>之间形成了一个<code>单向下行绑定</code>。以防止子组件意外更改父组件的状态，从而导致应用的数据流向难以理解。双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件都没有明显的变更来源</p><h2 id="过渡效果系统"><a href="#过渡效果系统" class="headerlink" title="过渡效果系统"></a>过渡效果系统</h2><p>Vue插入、更新、移除元素时自动应用过渡效果</p><h1 id="可复用性-amp-组合"><a href="#可复用性-amp-组合" class="headerlink" title="可复用性&amp;组合"></a>可复用性&amp;组合</h1><ul><li><p>mixin</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myMixin = &#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> Component = Vue.extend(&#123;</span><br><span class="line">  mixins: [myMixin]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> component = <span class="keyword">new</span> Component();</span><br></pre></td></tr></table></figure></li><li><p>自定义指令<code>Vue.directive()</code></p></li><li><p>渲染函数<code>render</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;xxx-xxx&#x27;</span>, &#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(</span><br><span class="line">      <span class="string">&#x27;h&#x27;</span> + <span class="built_in">this</span>.level,</span><br><span class="line">      <span class="built_in">this</span>.$slots.default</span><br><span class="line">    ),</span><br><span class="line">    props: &#123;</span><br><span class="line">      level: &#123;</span><br><span class="line">        type: <span class="built_in">Number</span>,</span><br><span class="line">        required: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过<code>babel插件@vue/babel-preset-jsx</code>可以使用jsx语法，接近于模板的语法上，Vue的模板实际上也是被编译成了渲染函数<code>Vue.compile</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;AnchoredHeading level=&#123;<span class="number">1</span>&#125;&gt;</span><br><span class="line">        &lt;span&gt;Hello&lt;/span&gt; world!</span><br><span class="line">      &lt;/AnchoredHeading&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>虚拟DOM：Vue通过建立一个虚拟DOM来追踪自己要如何改变真实DOM<br><code>createElement</code>返回一个虚拟节点<code>virtual node/VNode</code>包含信息告诉Vue页面上需要渲染什么样的节点，包括及其子节点的信息描述。</p></li></ul><h1 id="Vue插件"><a href="#Vue插件" class="headerlink" title="Vue插件"></a>Vue插件</h1><p>插件通常用来为 Vue 添加全局功能，如<code>vue-loader</code></p><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p><code>Vue.use()</code>在调用<code>new Vue()</code>启动应用之前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(MyPlugin)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="规模化"><a href="#规模化" class="headerlink" title="规模化"></a>规模化</h1><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NotFound = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;Page not found&lt;/p&gt;&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> Home = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;home page&lt;/p&gt;&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> About = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;about page&lt;/p&gt;&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = &#123;</span><br><span class="line">  <span class="string">&#x27;/&#x27;</span>: Home,</span><br><span class="line">  <span class="string">&#x27;/about&#x27;</span>: About</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    currentRoute: <span class="built_in">window</span>.location.pathname</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ViewComponent () &#123;</span><br><span class="line">      <span class="keyword">return</span> routes[<span class="built_in">this</span>.currentRoute] || NotFound</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render (h) &#123; <span class="keyword">return</span> h(<span class="built_in">this</span>.ViewComponent) &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>类Flux架构，store模式，集中式状态管理，组件不允许直接变更属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，这样能够记录所有 store 中发生的 state 变更，同时实现能做到记录变更、保存状态快照、历史回滚/时光旅行的先进的调试工具。<br><img src="./state.png"></p><h2 id="服务端渲染SSR"><a href="#服务端渲染SSR" class="headerlink" title="服务端渲染SSR"></a>服务端渲染SSR</h2><p>将一个组件渲染为服务端的HTML字符串，直接发送到浏览器，再将静态标记“激活”为客户端上可以交互的应用程序<br>使用SSR可以</p><ul><li>更好的SEO：搜索引擎爬虫工具可以直接查看完全渲染的页面</li><li>更快的内容到达时间（time-to-content）<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3>使用<code>vue-server-renderer</code>渲染一个Vue实例<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> renderer = <span class="built_in">require</span>(<span class="string">&#x27;vue-server-renderer&#x27;</span>).createRenderer(&#123;</span><br><span class="line">  template,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> context = &#123;</span><br><span class="line">    title: <span class="string">&#x27;vue ssr&#x27;</span>,</span><br><span class="line">    metas: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;meta name=&quot;keyword&quot; content=&quot;vue,ssr&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;meta name=&quot;description&quot; content=&quot;vue srr demo&quot;&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">server.get(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      url: req.url</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`&lt;div&gt;访问的 URL 是： &#123;&#123; url &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  renderer</span><br><span class="line">  .renderToString(app, context, <span class="function">(<span class="params">err, html</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(html);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      res.status(<span class="number">500</span>).end(<span class="string">&#x27;Internal Server Error&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.end(html);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><h3 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h3><blockquote><p>运行在服务器与客户端的代码</p></blockquote></li><li>服务器上默认情况下禁用响应式数据</li><li>生命周期只有<code>beforeCreate</code>与<code>created</code>会在服务端渲染过程中被调用，避免在期间产生有全局副作用的代码</li><li>通用代码不接受特定平台的API，如<code>window</code>或<code>document</code></li></ul><h3 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h3><ul><li>使用webpack对client与node端代码进行构建<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用app.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出一个工厂函数，用于创建新的</span></span><br><span class="line"><span class="comment">// 应用程序、router 和 store 实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// 根实例简单的渲染应用程序组件。</span></span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123; app &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// entry-client：将app挂载到dom上进行渲染执行</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; app &#125; = createApp()</span><br><span class="line"></span><br><span class="line">app.$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// entry-server：ssr中直接调用app，后续再执行</span></span><br><span class="line"><span class="comment">// 服务器端路由匹配 server-side route matching</span></span><br><span class="line"><span class="comment">// 和 数据预取逻辑 data pre-fetching logic</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> context =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; app &#125; = createApp()</span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="路由与代码分割"><a href="#路由与代码分割" class="headerlink" title="路由与代码分割"></a>路由与代码分割</h3><ul><li>路由</li><li>惰性加载（懒加载）：减少初始渲染中下载的资源体积，改善大体积bundle的可交互时间（time-to-interactive）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">&#x27;./Foo.vue&#x27;</span></span><br><span class="line"><span class="comment">// 改为</span></span><br><span class="line"><span class="keyword">const</span> Foo = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./Foo.vue&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据预取和状态"><a href="#数据预取和状态" class="headerlink" title="数据预取和状态"></a>数据预取和状态</h3><p><img src="https://ssr.vuejs.org/zh/guide/data.html" alt="数据预取和状态基于vuex"></p><h3 id="客户端激活"><a href="#客户端激活" class="headerlink" title="客户端激活"></a>客户端激活</h3><p> Vue 在浏览器端接管由服务端发送的静态 HTML，使其变为由 Vue 管理的动态 DOM 的过程。<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span> data-server-rendered=<span class="string">&quot;true&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="comment">// 强制使用应用程序的激活模式</span></span><br><span class="line">app.$mount(<span class="string">&#x27;#app&#x27;</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p><h2 id="预渲染Prerendering"><a href="#预渲染Prerendering" class="headerlink" title="预渲染Prerendering"></a>预渲染Prerendering</h2><p>改善少数页面的SEO使用预渲染<br>在构建时简单地生成针对特定路由的静态HTML文件</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Vue是一个用于构建用户界面的渐进式框架&lt;/strong&gt;，对于已存在的服务端应用，可将vue作为应用的一部分嵌入；如果将更多的业务逻辑放在前端，也可以用vue的核心库与生态系统来实现。&lt;/p&gt;</summary>
    
    
    
    
    <category term="vue2" scheme="https://chiokotomi.github.io/chio.github.io/tags/vue2/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化</title>
    <link href="https://chiokotomi.github.io/chio.github.io/2021/04/20/module-manage/"/>
    <id>https://chiokotomi.github.io/chio.github.io/2021/04/20/module-manage/</id>
    <published>2021-04-20T03:29:51.000Z</published>
    <updated>2021-05-10T13:27:29.374Z</updated>
    
    <content type="html"><![CDATA[<p>模块化的开发方式可以提高代码<strong>复用率</strong>，方便代码管理。一般一<strong>个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数</strong>。<span id="more"></span>模块化开发的核心问题就是引入js文件的<strong>顺序问题</strong>以及<strong>异步加载问题</strong>。<br>ES6之前，原生不支持模块化，所以出现了第三方的解决方案，分别是<code>AMD</code>与<code>CMD</code>，NodeJs诞生后使用<code>CommonJs</code>的模块化规范。</p><h1 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h1><p>异步模块定义<code>Asynchronous Module Definition</code>，是<code>RequireJs</code>在推广过程中对模块定义的规范化的产出。采用<strong>异步方式加载模块</strong>，模块的加载不影响后面的语句运行。所有依赖这个模块的语句，都定义在回调函数中。</p><p>用require.js实现AMD规范的模块化：用<code>require.config()</code>指定引用路径，用<code>define()</code>定义模块，用<code>require()</code>加载模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网页中引入require.js与main.js(配置require.config()规定用到的基础模块)</span></span><br><span class="line">&lt;script src=<span class="string">&quot;js/require.js&quot;</span> data-main=<span class="string">&quot;js/main&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js 入口文件</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">&#x27;js/lib&#x27;</span>,</span><br><span class="line">    paths: &#123;</span><br><span class="line">        <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;jquery.min&quot;</span>,</span><br><span class="line">        <span class="string">&quot;underscore&quot;</span>: <span class="string">&quot;underscore.min&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>引入模块时，将模块名放在<code>[]</code>中作为<code>require()</code>的第一参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义math.js模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add: add,</span><br><span class="line">        basicNum: basicNum</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入模块</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;jquery&#x27;</span>, <span class="string">&#x27;math&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$, math</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum = math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    $(<span class="string">&quot;$sum&quot;</span>).htm(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>若定义的模块依赖其他模块，则需要放在<code>[]</code>中作为<code>define</code>的第一个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">&#x27;underscore&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">_</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> classify = <span class="function"><span class="keyword">function</span> (<span class="params">list</span>) </span>&#123;</span><br><span class="line">        _.countBy(list, <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num &gt; <span class="number">30</span> ? <span class="string">&#x27;old&#x27;</span> : <span class="string">&#x27;young&#x27;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">classify</span>: classify&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><p>通用模块加载规范<code>Common Module Definition</code>，是<code>Sea.js</code>实现的规范。</p><p>AMD实现者require.js在申明依赖的模块时，会第一时间加载并执行模块内代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AMD写法</span></span><br><span class="line"><span class="comment">// 声明并初始化所有要用到的模块</span></span><br><span class="line">define([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 即使未用到模块b，b依旧会提前执行 **这就是CMD要优化的地方**</span></span><br><span class="line">        b.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>CMD与AMD类似，不同点在于：<strong>AMD推崇依赖前置，提前执行，CMD推崇依赖就近，延迟执行</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMD写法</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="keyword">export</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>);</span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>);</span><br><span class="line">        b.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sea.js</span></span><br><span class="line"><span class="comment">// 定义模块math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="keyword">export</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery.js&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">export</span>.add = add;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">&#x27;math.js&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = math.add(<span class="number">2</span> + <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h1><p>NodeJS是主要实践者，需要四个重要的环境变量为模块化的实现提供支持<code>module</code>、<code>exports</code>、<code>require</code>、<code>global</code>。<br><code>module.exports</code>定义对外输出的接口，<code>require</code>加载模块。</p><blockquote><p>问题：<br>CommonJS用<strong>同步</strong>的方式加载模块。在服务器端，模块文件存放本地磁盘，读取非常快。<strong>但在浏览器端，限于网络原因，更合理的方案是使用异步加载</strong>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义模块math.js</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    add: add,</span><br><span class="line">    basicNum: basicNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入自定义模块</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./math&#x27;</span>);</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h1 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h1><p>UMD（Universal Module Definition）是AMD和CommonJs的统一规范，支持两种规范，写一套代码，可用于多种场景。</p><ul><li>写法最复杂</li><li>前后端通用</li><li>UMD更像是一种配置多个模块系统的模式</li><li>UMD在使用诸如Rollup/Webpack之类的bundler时通常用作备用模块</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        <span class="comment">// AMD</span></span><br><span class="line">        define([<span class="string">&#x27;jquery]&#x27;</span>, factory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// Node CommonJs</span></span><br><span class="line">        <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">&#x27;jquery&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 浏览器全局变量</span></span><br><span class="line">        root.returnExports = factory(root.jquery);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="built_in">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定义方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">myFunc</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暴露公共方法</span></span><br><span class="line">    <span class="keyword">return</span> myFunc;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="ESM-ES6-Module"><a href="#ESM-ES6-Module" class="headerlink" title="ESM / ES6 Module"></a>ESM / ES6 Module</h1><blockquote><p>ES6在语言标准层面上，实现了模块功能。成为浏览器和服务器通用的模块解决方案。<br>ES6模块不是对象，<code>import</code>命令会被js引擎静态分析，在编译时就引入模块代码，而且不在运行时加载，所以无法实现条件加载。</p></blockquote><p>主要包含两个命令：<code>export</code>规定对外接口，<code>import</code>输入其他模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义math.js</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;basicNum, add&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">import</span> &#123;basicNum, add&#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    ele.textContent =  add(<span class="number">99</span> + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ES6模块与CommonJS模块差异"><a href="#ES6模块与CommonJS模块差异" class="headerlink" title="ES6模块与CommonJS模块差异"></a>ES6模块与CommonJS模块差异</h1><h2 id="CommonJs模块输出的是一个值的拷贝，ES6模块输出的是值的引用"><a href="#CommonJs模块输出的是一个值的拷贝，ES6模块输出的是值的引用" class="headerlink" title="CommonJs模块输出的是一个值的拷贝，ES6模块输出的是值的引用"></a>CommonJs模块输出的是一个值的拷贝，ES6模块输出的是值的引用</h2><ul><li>CommonJs模块输出的是一个<strong>值的拷贝</strong>，一旦输出一个值，模块内部的变化影响不到这个值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">num</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    b = &#123;<span class="attr">num</span>: <span class="number">2</span>&#125;;</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;a, b&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">let</span> &#123;a, b&#125; = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b);   <span class="comment">// &#123;num: 1&#125;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(b);   <span class="comment">// &#123;num: 1&#125;</span></span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure></li></ul><p><strong>输出拷贝<code>exports</code>对象是模块内外的唯一关联，CommonJs输出的内容，就是<code>exports</code>对象的属性，模块运行结束，属性就确定了。</strong></p><ul><li>ES6模块的运行机制：JS引擎对脚本静态分析时，遇到<code>import</code>会生成一个<strong>只读引用</strong>。在脚本真正执行时，再根据引用到被加载的模块里去取值。ES6模块是动态引用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">num</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    b = &#123;<span class="attr">num</span>: <span class="number">2</span>&#125;;</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    a,</span><br><span class="line">    b</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;a, b&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// &#123;num: 1&#125;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(b);  <span class="comment">// &#123;num: 2&#125;</span></span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="CommonJs模块时运行时加载，ES6模块时编译时输出"><a href="#CommonJs模块时运行时加载，ES6模块时编译时输出" class="headerlink" title="CommonJs模块时运行时加载，ES6模块时编译时输出"></a>CommonJs模块时运行时加载，ES6模块时编译时输出</h2><ul><li>运行时加载： 输入时先加载整个模块，生成一个对象，再从这个对象上读取方法。</li><li>编译时加载： <code>import</code>时指定加载某个输出值，而不是加载整个模块。模块内部引用的变化，会反应在外部。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;模块化的开发方式可以提高代码&lt;strong&gt;复用率&lt;/strong&gt;，方便代码管理。一般一&lt;strong&gt;个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数&lt;/strong&gt;。</summary>
    
    
    
    
    <category term="module" scheme="https://chiokotomi.github.io/chio.github.io/tags/module/"/>
    
  </entry>
  
  <entry>
    <title>面向对象编程与函数式编程</title>
    <link href="https://chiokotomi.github.io/chio.github.io/2021/04/20/oop-fp/"/>
    <id>https://chiokotomi.github.io/chio.github.io/2021/04/20/oop-fp/</id>
    <published>2021-04-20T03:19:02.000Z</published>
    <updated>2021-05-11T04:01:38.996Z</updated>
    
    <content type="html"><![CDATA[<p>OOP与FP是不同的编程风格，了解各自的优缺点结合使用</p><span id="more"></span><h1 id="面向对象编程object-oriented-programming"><a href="#面向对象编程object-oriented-programming" class="headerlink" title="面向对象编程object oriented programming"></a>面向对象编程object oriented programming</h1><p>把计算机程序视为一组对象的合集，每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间的传递。</p><blockquote><p>强调<code>状态property</code>与<code>操作method</code>的封装，设计思想：抽象出Class，根据Class创建Instance</p></blockquote><h2 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h2><ul><li>封装：把客观事物封装成抽象的类。保护私有属性与方法</li><li>继承：从父类获得属性和方法，实现代码复用</li><li>多态：同一事物的多种形态，多个对象有相同的使用方法<ul><li>重写overriding：子类有与父类一样的方法名，但是有自己的逻辑，子类与父类的多态性</li><li>重载overloading：一个类有多个一样的方法名，但是参数不同，一个类的多态性</li></ul></li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li>优点：易维护、复用、扩展。可设计出低耦合、更灵活的系统。</li></ul><h2 id="JS实现OOP"><a href="#JS实现OOP" class="headerlink" title="JS实现OOP"></a>JS实现OOP</h2><p>在js中使用OOP有四种方式</p><ul><li>工场函数</li><li>Function constructor构造器函数</li><li>Object.create()</li><li>ES6 classes</li></ul><h3 id="工场函数"><a href="#工场函数" class="headerlink" title="工场函数"></a>工场函数</h3><p>创建接收参数返回对象的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personA = &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;lorem&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;ipsum&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">getFullName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Full name is: <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personB = &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;retrum&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;massa&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">getFullName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Full name is: <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person = <span class="function"><span class="keyword">function</span> (<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        firstName,</span><br><span class="line">        lastName,</span><br><span class="line">        <span class="function"><span class="title">getFullName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">`Full name is <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personC = person(<span class="string">&#x27;erat&#x27;</span>, <span class="string">&#x27;luctus&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如上使用工场函数可以避免代码重复，但是因为每次使用<code>person</code>函数时，<code>getFullName</code>都被重复创建，使用Function constructor方式可以提高内存使用效率。</p><h3 id="Function-constructor"><a href="#Function-constructor" class="headerlink" title="Function constructor"></a>Function constructor</h3><p>使用<code>new</code>关键词初始化的函数即为构造器函数，并且最好使用大写首字母</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">    <span class="built_in">this</span>.lastName = lastName</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.getFullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Full name is <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personA = <span class="keyword">new</span> Person(<span class="string">&#x27;lorem&#x27;</span>,<span class="string">&#x27;ipsum&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> personB = <span class="keyword">new</span> Person(<span class="string">&#x27;felis&#x27;</span>,<span class="string">&#x27;ullamcorper&#x27;</span>);</span><br><span class="line"></span><br><span class="line">personA.getFullName();</span><br></pre></td></tr></table></figure><p>使用构造器与prototype实现了代码复用，<code>personA</code>与<code>personB</code>两个实例有各自不同的firstName与lastName，但是在原型上有共同的函数<code>getFullName</code>，通过原型链使得构造器函数更高效的利用了内存。</p><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p><code>Object.create()</code>可以使用一个已经存在的对象作为一个新对象的原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;retrum&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;massa&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">getFullName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Full name is <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personA = <span class="built_in">Object</span>.create(person);</span><br><span class="line">personA.firstName = <span class="string">&#x27;ullam&#x27;</span>;</span><br><span class="line">personA.lastName = <span class="string">&#x27;ipsum&#x27;</span>;</span><br><span class="line">personA.getFullName();</span><br></pre></td></tr></table></figure><h3 id="ES6-classes"><a href="#ES6-classes" class="headerlink" title="ES6 classes"></a>ES6 classes</h3><p>es6的class关键词可以创建oop，是一种语法糖本质依旧是原型继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每个实例都不同的属性需要放在constructor里，所有实例共享的方法在外面</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">firstName, lastName</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getFullName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Full name is <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数式编程functional-programming"><a href="#函数式编程functional-programming" class="headerlink" title="函数式编程functional programming"></a>函数式编程functional programming</h1><p>所有的程序里两个核心的东西是<strong>数据data</strong>与<strong>行为behavior</strong>。</p><p>函数式编程主张数据与行为分离。将代码分成不同的部分，可以保证每一个部分都能被很好的组织。简言之，应该传递数据给函数，函数操作后返回新对象。</p><p>一个函数应该满足以下特点：</p><ol><li>单任务：函数尽量的小执行单一的任务</li><li>纯函数：函数不应该有副作用，相同的输入有相同的输出</li><li>函数应该有返回<code>return statement</code></li><li>函数应该是可组合的<code>compose-able</code></li><li>函数应该是不变的<code>immutable</code>：函数应该返回一个数据的copy，而不应该改变原始数据</li><li>函数应该是可测的<code>predictable</code></li></ol><h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>保证以下几点的是纯函数</p><ul><li>1.相同的输入，永远会得到相同的输出，无论函数被执行多少次<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwoNumber</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addTwoNmber(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// will return 7 no matter how many times is called</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyWithCurrentTime</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num * <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">multiplyWithCurrentTime(<span class="number">3</span>);<span class="comment">// will provide new output each time we call the funciton</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>2.计算返回值时不会产生副作用(side effect)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In this example i want to clear out the difference between function with side effect and a function without side effect</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeLastItem</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    input.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">removeLastItem(arr); </span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// output [1,2] (this function changes the orignal variable from [1,2,3] -&gt; [1,2])</span></span><br><span class="line"><span class="comment">// above execution has side effect as it mutate arr which belong to the outside world.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">immutablyRemoveLastItem</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newArray = [].concat(input); <span class="comment">// concat method copies the value to new variable.</span></span><br><span class="line">    <span class="keyword">return</span> newArray.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(immutablyRemoveLastItem(newArr)); <span class="comment">// output [1,2]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// output [1,2,3] -&gt; the above function does not have side effect as it not modify the orignal input instead it copies</span></span><br><span class="line"><span class="comment">// and alter the copied array.</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="引用透明"><a href="#引用透明" class="headerlink" title="引用透明"></a>引用透明</h2><p>一个表达式可以被他的值代替并不会造成其他影响</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function">(<span class="params">num1,num2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b(a(<span class="number">3</span>,<span class="number">4</span>))) <span class="comment">//output will be 14</span></span><br><span class="line"><span class="comment">// here i can replace a(3,4) expression with value 7 value and this will not effect to the result of the program because its return</span></span><br><span class="line"><span class="comment">// value is 7</span></span><br><span class="line"><span class="comment">// so i can replace  console.log(b(a(3,4))) to console.log(b(7)) as a function is refrencially transparent</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="function">(<span class="params">num1,num2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Value of num1:<span class="subst">$&#123;num1&#125;</span> and value of num2:<span class="subst">$&#123;num2&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b(c(<span class="number">3</span>,<span class="number">4</span>))) <span class="comment">//output will be 14</span></span><br><span class="line"><span class="comment">// here i cannot replace expression c(3,4) with value 7 as it effect the result of the program</span></span><br><span class="line"><span class="comment">// function c has console.log() which is one type of side effect so it is not referentially transparent</span></span><br></pre></td></tr></table></figure><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>一个函数相同输入有相同输出，那么函数就是幂等的。不同于纯函数，幂等性允许函数有副作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非幂等，每次输出都不同</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">notIdempotenceFn</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">notIdempotenceFn(<span class="number">5</span>);</span><br><span class="line">notIdempotenceFn(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 幂等但非纯函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">idempotentFn</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 幂等</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAbsolute</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(x)</span><br><span class="line">&#125;</span><br><span class="line">getAbsolute(getAbsolute(getAbsolute(-<span class="number">50</span>))) <span class="comment">//50</span></span><br></pre></td></tr></table></figure><h2 id="命令式vs声明式"><a href="#命令式vs声明式" class="headerlink" title="命令式vs声明式"></a>命令式vs声明式</h2><p>命令式Imperative：告诉做什么、怎么做<br>声明式Declarative：告诉做什么、什么需要被完成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Imerative命令式</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123; <span class="comment">// 怎么做：定义变量i，直到5向上++</span></span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 做什么：console.log(i)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Declarative声明式</span></span><br><span class="line"><span class="comment">// 做什么：console.log(item)</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].forEach(<span class="function"><span class="params">item</span>=&gt;</span><span class="built_in">console</span>.log(item));</span><br></pre></td></tr></table></figure><p>函数式编程通过使用<code>compose</code>让我们更加偏向声明式，<code>compose</code>告诉我们程序要做什么而不是怎么去做</p><h2 id="Immutability不变性"><a href="#Immutability不变性" class="headerlink" title="Immutability不变性"></a>Immutability不变性</h2><p>不更改原始状态，而是复制一个新的状态把改变应用到新状态上后返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mutateObj = &#123;</span><br><span class="line">    first_name:<span class="string">&#x27;lorem&#x27;</span>,</span><br><span class="line">    last_name:<span class="string">&#x27;ipsum&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> immutateObj = &#123;</span><br><span class="line">    first_name:<span class="string">&#x27;irum&#x27;</span>,</span><br><span class="line">    last_name:<span class="string">&#x27;egestas&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutatingState = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    obj.first_name = <span class="string">&#x27;ullamcorper&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> immutatingState = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> copiedObj = <span class="built_in">Object</span>.assign(&#123;&#125;,obj);</span><br><span class="line">    copiedObj.first_name = <span class="string">&#x27;facilisis&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> copiedObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutatingState(mutateObj);</span><br><span class="line"><span class="built_in">console</span>.log(mutateObj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">above output &#123;</span></span><br><span class="line"><span class="comment">  first_name:&#x27;ullamcorper&#x27;,</span></span><br><span class="line"><span class="comment">  last_name:&#x27;ipsum&#x27;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">in the above function we have mutated the orignal state</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> newObj = immutatingState(immutateObj);</span><br><span class="line"><span class="built_in">console</span>.log(immutateObj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">newObj will be </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  first_name:&#x27;facilisis&#x27;,</span></span><br><span class="line"><span class="comment">  last_name:&#x27;egestas&#x27;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">and  immutateObj will not be changed and it value is</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  first_name:&#x27;irum&#x27;,</span></span><br><span class="line"><span class="comment">  last_name:&#x27;egestas&#x27;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">here the orignal state is not change</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>函数式编程建议immutability，因为immutability给我们代码带来稳定性与保护性。</p><h2 id="高阶函数high-order-function"><a href="#高阶函数high-order-function" class="headerlink" title="高阶函数high order function"></a>高阶函数high order function</h2><p>一个函数接收函数作为参数，或者返回是一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hocFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">hocFn() <span class="comment">// will return function</span></span><br><span class="line">hocFn()() <span class="comment">// will return 5</span></span><br><span class="line"><span class="comment">// hocFn return function so it is HOC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hocFn2 = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hocFn2(fn); <span class="comment">// will return 10</span></span><br><span class="line"><span class="comment">// hocFn2 accept function as argument it is an HOC</span></span><br></pre></td></tr></table></figure><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>柯里化是把一个接收很多参数的函数，转成很多接收一个参数的函数的技巧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a * b;</span><br><span class="line">multiply(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curring = <span class="function"><span class="params">a</span> =&gt;</span> <span class="function"><span class="params">b</span> =&gt;</span> a * b;</span><br><span class="line">curring(<span class="number">5</span>)(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h2 id="局部应用"><a href="#局部应用" class="headerlink" title="局部应用"></a>局部应用</h2><p>partially applying a function</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a,b,c</span>) =&gt;</span> a * b * c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Partial Application</span></span><br><span class="line"><span class="keyword">const</span> partiallyMultiplyBy5 = multiply.bind(<span class="literal">null</span>, <span class="number">5</span>); <span class="comment">// 局部应用5作为第一个参数</span></span><br><span class="line">partiallyMultiplyBy5(<span class="number">4</span>, <span class="number">10</span>) <span class="comment">//200  // 此时执行时传入剩余参数</span></span><br></pre></td></tr></table></figure><h2 id="记忆化Memoization"><a href="#记忆化Memoization" class="headerlink" title="记忆化Memoization"></a>记忆化Memoization</h2><p>缓存的一种特殊形式</p><h2 id="组合compose与管道pipe"><a href="#组合compose与管道pipe" class="headerlink" title="组合compose与管道pipe"></a>组合compose与管道pipe</h2><p><code>组合compose</code>是一种描述函数间关系的设计规则。<code>管道pipe</code>与组合类似，区别在于调用上。组合从右向左执行，管道从左向右执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiplyWith3  = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> getAbsouleOfNum = <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">Math</span>.abs(x);</span><br><span class="line"><span class="comment">// 正常实现给一个值乘3后取模</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">let</span> xAfterMultiply = multiplyWith3(x);</span><br><span class="line"><span class="keyword">let</span> xAfterAbsoulte = getAbsouleOfNum(xAfterMultiply);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过组合的形式：安排两个函数的调用顺序</span></span><br><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> f(g(data));</span><br><span class="line"><span class="keyword">const</span> multiplyBy3andGetAbsolute = compose(multiplyWith3, getAbsouleOfNum);</span><br><span class="line">multiplyBy3andGetAbsolute(-<span class="number">15</span>); <span class="comment">//45</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过管道的形式</span></span><br><span class="line"><span class="keyword">const</span> pipe = <span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> g(f(data));</span><br><span class="line"><span class="keyword">const</span> multiplyBy3andGetAbsolutePipe = pipe(multiplyWith3, getAbsouleOfNum);</span><br><span class="line">multiplyBy3andGetAbsolutePipe(-<span class="number">15</span>);</span><br></pre></td></tr></table></figure><h2 id="arity参数数量"><a href="#arity参数数量" class="headerlink" title="arity参数数量"></a>arity参数数量</h2><p>函数化编程建议使用更改少的函数参数（建议1-2个），以让函数更好用。</p><h1 id="OOP-vs-FP"><a href="#OOP-vs-FP" class="headerlink" title="OOP vs FP"></a>OOP vs FP</h1><p>OOP强调<code>data</code>与<code>operation</code>的封装，具有封装、继承、多态的主要特点。FP强调<code>data</code>与<code>operation</code>的分离，实现纯函数，避免副作用，通过函数组合实现更强的功能。</p><h2 id="共同性"><a href="#共同性" class="headerlink" title="共同性"></a>共同性</h2><p>OOP与FP都是为了让我们的代码更可控的设计模式，代码可控意味着：</p><ul><li>易读性</li><li>易扩展</li><li>易维护</li><li>内存高效：oop-继承，fp-闭包</li><li>DRY（don’t repeat yourself）：避免代码重复<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2></li><li>FP 擅于处理在很多操作中修改数据；OOP 擅长处理在少操作中修改共同数据</li><li>FP 是无状态的，不会影响程序的其他状态；OOP是有状态的，会改变属性的状态</li><li>FP 有无副作用的纯函数；OOP因为修改自己的状态，所有有副作用</li><li>FP 是声明式的，专注于该完成什么；OOP是命令式的，专注于如何去做</li></ul><h2 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h2><ul><li>操作多，高性能是用FP</li><li>角色对象多操作少的情况用OOP</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;OOP与FP是不同的编程风格，了解各自的优缺点结合使用&lt;/p&gt;</summary>
    
    
    
    
    <category term="oop" scheme="https://chiokotomi.github.io/chio.github.io/tags/oop/"/>
    
  </entry>
  
  <entry>
    <title>es5-es6-es7</title>
    <link href="https://chiokotomi.github.io/chio.github.io/2021/04/14/es5-es6-es7/"/>
    <id>https://chiokotomi.github.io/chio.github.io/2021/04/14/es5-es6-es7/</id>
    <published>2021-04-14T13:14:48.000Z</published>
    <updated>2021-04-26T03:57:27.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h1><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN doc</a> </p><blockquote><p>taken from stackoverflow</p></blockquote><p>Property is an OOP feature designed for clean separation of client code. For example, in some e-shop you might have objects like this:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name,price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line">  <span class="built_in">this</span>.discount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sneakers = <span class="keyword">new</span> Product(<span class="string">&quot;Sneakers&quot;</span>,<span class="number">20</span>); <span class="comment">// &#123;name:&quot;Sneakers&quot;,price:20,discount:0&#125;</span></span><br><span class="line"><span class="keyword">var</span> tshirt = <span class="keyword">new</span> Product(<span class="string">&quot;T-shirt&quot;</span>,<span class="number">10</span>);  <span class="comment">// &#123;name:&quot;T-shirt&quot;,price:10,discount:0&#125;</span></span><br></pre></td></tr></table></figure><p>Then in your client code (the e-shop), you can add discounts to your products:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">badProduct</span>(<span class="params">obj</span>) </span>&#123; obj.discount+= <span class="number">20</span>; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generalDiscount</span>(<span class="params">obj</span>) </span>&#123; obj.discount+= <span class="number">10</span>; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distributorDiscount</span>(<span class="params">obj</span>) </span>&#123; obj.discount+= <span class="number">15</span>; ... &#125;</span><br></pre></td></tr></table></figure><p>Later, the e-shop owner might realize that the discount can’t be greater than say 80%. Now you need to find EVERY occurrence of the discount modification in the client code and add a line</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj.discount&gt;<span class="number">80</span>) obj.discount = <span class="number">80</span>;</span><br></pre></td></tr></table></figure><p>Then the e-shop owner may further change his strategy, like “if the customer is reseller, the maximal discount can be 90%”. And you need to do the change on multiple places again plus you need to remember to alter these lines anytime the strategy is changed. This is a bad design. That’s why encapsulation is the basic principle of OOP. If the constructor was like this:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name,price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _name=name, _price=price, _discount=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line">  <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; _name = value; &#125;</span><br><span class="line">  <span class="built_in">this</span>.getPrice = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> _price; &#125;</span><br><span class="line">  <span class="built_in">this</span>.setPrice = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; _price = value; &#125;</span><br><span class="line">  <span class="built_in">this</span>.getDiscount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> _discount; &#125;</span><br><span class="line">  <span class="built_in">this</span>.setDiscount = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; _discount = value; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then you can just alter the getDiscount (accessor) and setDiscount (mutator) methods. The problem is that most of the members behave like common variables, just the discount needs special care here. But good design requires encapsulation of every data member to keep the code extensible. So you need to add lots of code that does nothing. This is also a bad design, a boilerplate antipattern. Sometimes you can’t just refactor the fields to methods later (the eshop code may grow large or some third-party code may depend on the old version), so the boilerplate is lesser evil here. But still, it is evil. That’s why properties were introduced into many languages. You could keep the original code, just transform the discount member into a property with get and set blocks:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name,price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line"><span class="comment">//this.discount = 0; // &lt;- remove this line and refactor with the code below</span></span><br><span class="line">  <span class="keyword">var</span> _discount; <span class="comment">// private member</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>,<span class="string">&quot;discount&quot;</span>,&#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> _discount; &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; _discount = value; <span class="keyword">if</span>(_discount&gt;<span class="number">80</span>) _discount = <span class="number">80</span>; &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the client code</span></span><br><span class="line"><span class="keyword">var</span> sneakers = <span class="keyword">new</span> Product(<span class="string">&quot;Sneakers&quot;</span>,<span class="number">20</span>);</span><br><span class="line">sneakers.discount = <span class="number">50</span>; <span class="comment">// 50, setter is called</span></span><br><span class="line">sneakers.discount+= <span class="number">20</span>; <span class="comment">// 70, setter is called</span></span><br><span class="line">sneakers.discount+= <span class="number">20</span>; <span class="comment">// 80, not 90!</span></span><br><span class="line">alert(sneakers.discount); <span class="comment">// getter is called</span></span><br></pre></td></tr></table></figure><p>Note the last but one line: the responsibility for correct discount value was moved from the client code (e-shop definition) to the product definition. The product is responsible for keeping its data members consistent. Good design is (roughly said) if the code works the same way as our thoughts.</p><p>So much about properties. But javascript is different from pure Object-oriented languages like C# and codes the features differently:</p><p>In C#, transforming fields into properties is a breaking change, so public fields should be coded as Auto-Implemented Properties if your code might be used in the separately compiled client.</p><p>In Javascript, the standard properties (data member with getter and setter described above) are defined by accessor descriptor (in the link you have in your question). Exclusively, you can use data descriptor (so you can’t use i.e. value and set on the same property):</p><ul><li><p>accessor descriptor = get + set (see the example above)</p><ul><li>get must be a function; its return value is used in reading the property; if not specified, the default is undefined, which behaves like a function that returns undefined</li><li>set must be a function; its parameter is filled with RHS in assigning a value to property; if not specified, the default is undefined, which behaves like an empty function</li></ul></li><li><p>data descriptor = value + writable (see the example below)</p><ul><li>value default undefined; if writable, configurable and enumerable (see below) are true, the property behaves like an ordinary data field</li><li>writable - default false; if not true, the property is read only; attempt to write is ignored without error*!<br>Both descriptors can have these members:</li></ul></li><li><p>configurable - default false; if not true, the property can’t be deleted; attempt to delete is ignored without error*!</p></li><li><p>enumerable - default false; if true, it will be iterated in for(var i in theObject); if false, it will not be iterated, but it is still accessible as public</p></li></ul><ul><li>unless in strict mode - in that case JS stops execution with TypeError unless it is caught in try-catch block</li></ul><p>To read these settings, use Object.getOwnPropertyDescriptor().</p><p>Learn by example:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&quot;test&quot;</span>,&#123;</span><br><span class="line">  value: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&quot;test&quot;</span>)); <span class="comment">// check the settings    </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> o) <span class="built_in">console</span>.log(o[i]); <span class="comment">// nothing, o.test is not enumerable</span></span><br><span class="line"><span class="built_in">console</span>.log(o.test); <span class="comment">// &quot;a&quot;</span></span><br><span class="line">o.test = <span class="string">&quot;b&quot;</span>; <span class="comment">// o.test is still &quot;a&quot;, (is not writable, no error)</span></span><br><span class="line"><span class="keyword">delete</span>(o.test); <span class="comment">// bye bye, o.test (was configurable)</span></span><br><span class="line">o.test = <span class="string">&quot;b&quot;</span>; <span class="comment">// o.test is &quot;b&quot;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> o) <span class="built_in">console</span>.log(o[i]); <span class="comment">// &quot;b&quot;, default fields are enumerable</span></span><br></pre></td></tr></table></figure><p>If you don’t wish to allow the client code such cheats, you can restrict the object by three levels of confinement:</p><ul><li>Object.preventExtensions(yourObject) prevents new properties to be added to yourObject. Use Object.isExtensible(<yourObject>) to check if the method was used on the object. The prevention is shallow (read below).</li><li>Object.seal(yourObject) same as above and properties can not be removed (effectively sets configurable: false to all properties). Use Object.isSealed(<yourObject>) to detect this feature on the object. The seal is shallow (read below).</li><li>Object.freeze(yourObject) same as above and properties can not be changed (effectively sets writable: false to all properties with data descriptor). Setter’s writable property is not affected (since it doesn’t have one). The freeze is shallow: it means that if the property is Object, its properties ARE NOT frozen (if you wish to, you should perform something like “deep freeze”, similar to deep copy - cloning). Use Object.isFrozen(<yourObject>) to detect it.</li></ul><p>You don’t need to bother with this if you write just a few lines fun. But if you want to code a game (as you mentioned in the linked question), you should care about good design. Try to google something about antipatterns and code smell. It will help you to avoid situations like “Oh, I need to completely rewrite my code again!”, it can save you months of despair if you want to code a lot.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;es6&quot;&gt;&lt;a href=&quot;#es6&quot; class=&quot;headerlink&quot; title=&quot;es6&quot;&gt;&lt;/a&gt;es6&lt;/h1&gt;&lt;h2 id=&quot;Object-defineProperty&quot;&gt;&lt;a href=&quot;#Object-defineProperty&quot; class</summary>
      
    
    
    
    
    <category term="es6" scheme="https://chiokotomi.github.io/chio.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>vue3学习笔记</title>
    <link href="https://chiokotomi.github.io/chio.github.io/2021/04/10/vue3/"/>
    <id>https://chiokotomi.github.io/chio.github.io/2021/04/10/vue3/</id>
    <published>2021-04-10T15:13:43.000Z</published>
    <updated>2021-04-22T13:29:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>vue3 比 vue2 加了什么功能</li><li>vue 设计思想，实现了什么功能，怎么实现的</li><li>vue 支持到的ie版本</li><li>vue 生态其他库的作用是什么</li><li>vue3跟typescript关系是什么，好用在哪里</li><li>预渲染与服务端渲染如何实现的</li></ul><h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><h2 id="放弃支持IE11"><a href="#放弃支持IE11" class="headerlink" title="放弃支持IE11"></a>放弃支持IE11</h2><blockquote><p>参考vue RFC <a href="https://github.com/vuejs/rfcs/blob/ie11/active-rfcs/0000-vue3-ie11-support.md">proposal for dropping ie11 support in Vue3</a></p></blockquote><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ol><li>浏览器和js的环境发生变化，越来越多的开发者开始使用现代语言特性</li><li>微软通过投资Edge推动用户停止对IE的使用，同时在自己的<code>Microsoft 365</code>重大项目中放弃使用IE11</li><li>WordPress放弃支持IE11</li><li>IE11全球使用率跌破1%以下</li></ol><h3 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h3><h4 id="1-行为不一致"><a href="#1-行为不一致" class="headerlink" title="1. 行为不一致"></a>1. 行为不一致</h4><ul><li><p>原因：<code>响应式系统的实现</code>在<code>vue2</code>中基于<code>ES5的getter/setter</code>，在<code>vue3</code>中基于<code>ES2015 Proxies</code>，更高性能更完整的响应式系统。ie11中无法<code>polyfill</code>这些特性。</p></li><li><p>好处： <code>vue3基于Proxy</code>的响应式系统提供了<code>近乎完整的</code>语言特性覆盖：可以检测到许多在ES5中不可行或不可能的操作，如<code>属性的添加/删除</code>、<code>数组索引和长度突变</code>以及<code>in操作符的检查等功能</code>。</p></li><li><p>支持方案：使vue3在ie11版本的开发构建中同时发布<code>Proxy</code>和<code>ES5</code>两种响应性版本。</p></li><li><p>结论： 理论可行，复杂度大，需要将两种实现混合在一起，可能导致<em><strong>开发和生产之间的行为差异</strong></em></p></li></ul><h4 id="2-长期维护负担"><a href="#2-长期维护负担" class="headerlink" title="2. 长期维护负担"></a>2. 长期维护负担</h4><p>支持ie11就必须考虑整个代码库中使用的语言特性与为发布版本找到合适的polyfill编译策略。</p><p>每一个不能在ie11中被polyfill的新特性都会带来新的行为警告</p><h4 id="3-库作者的复杂性"><a href="#3-库作者的复杂性" class="headerlink" title="3. 库作者的复杂性"></a>3. 库作者的复杂性</h4><p>两个响应性实现也会不可避免的影响vue生态其他库作者开发，若决定支持IE11，在编写库时，需要时刻考虑ES5响应系统的一些缺陷。</p><h2 id="新功能"><a href="#新功能" class="headerlink" title="新功能"></a>新功能</h2><ul><li>composition API</li><li><code>&lt;script setup&gt;</code> 与其他新的<code>单文件组件(SFC)</code>特性</li><li>emits 选项</li><li>TS 类型改进</li><li>Vite官方整合</li></ul><h1 id="Next-To-Learn"><a href="#Next-To-Learn" class="headerlink" title="Next To Learn"></a>Next To Learn</h1><ul><li>data 属性设定与作用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;vue3 比 vue2 加了什么功能&lt;/li&gt;
&lt;li&gt;vue 设计思想，实现了什么功能，怎么实现的&lt;/li&gt;
&lt;li&gt;vue </summary>
      
    
    
    
    
    <category term="vue" scheme="https://chiokotomi.github.io/chio.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>学习列表</title>
    <link href="https://chiokotomi.github.io/chio.github.io/2021/04/09/to-learn-list/"/>
    <id>https://chiokotomi.github.io/chio.github.io/2021/04/09/to-learn-list/</id>
    <published>2021-04-09T02:11:02.000Z</published>
    <updated>2021-04-21T02:59:10.340Z</updated>
    
    <content type="html"><![CDATA[<ul><li>vue</li><li>react</li><li>webpack</li><li>babel/polyfill</li><li>ng</li><li>es6 es7</li><li>架构师</li><li>重构</li><li>数据结构与算法</li><li>leetcode</li><li>d3.js</li><li>bootstrap/wordpress</li><li>微服务、懒加载、预渲染、服务端渲染</li><li>性能优化</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;vue&lt;/li&gt;
&lt;li&gt;react&lt;/li&gt;
&lt;li&gt;webpack&lt;/li&gt;
&lt;li&gt;babel/polyfill&lt;/li&gt;
&lt;li&gt;ng&lt;/li&gt;
&lt;li&gt;es6 es7&lt;/li&gt;
&lt;li&gt;架构师&lt;/li&gt;
&lt;li&gt;重构&lt;/li&gt;
&lt;li&gt;数据结构与算法&lt;</summary>
      
    
    
    
    
    <category term="oop" scheme="https://chiokotomi.github.io/chio.github.io/tags/oop/"/>
    
  </entry>
  
</feed>

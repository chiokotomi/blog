<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chio&#39;s Personal Website</title>
  
  
  <link href="https://chiokotomi.github.io/chio.github.io/atom.xml" rel="self"/>
  
  <link href="https://chiokotomi.github.io/chio.github.io/"/>
  <updated>2021-04-27T00:36:36.947Z</updated>
  <id>https://chiokotomi.github.io/chio.github.io/</id>
  
  <author>
    <name>Chio</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web Components</title>
    <link href="https://chiokotomi.github.io/chio.github.io/2021/04/26/webComponents/"/>
    <id>https://chiokotomi.github.io/chio.github.io/2021/04/26/webComponents/</id>
    <published>2021-04-26T04:01:18.000Z</published>
    <updated>2021-04-27T00:36:36.947Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Web Components</strong> 可以创建可复用的定制元素，包含三项主要技术。</p><ol><li><strong>Custom elements （自定义元素）：</strong>JS API，可以定义custom elements及其行为，在用户界面中按需求使用。</li><li><strong>Shadow DOM （影子DOM）：</strong>JS API，用于将封装的影子DOM树附加到元素（与主文档DOM分开呈现）并控制其关联功能。这样可以保持元素的功能私有，可以被脚本化和样式化，不会与文档的其他部分发生冲突。</li><li><strong>HTML templates（HTML模板）：</strong> <code>&lt;template&gt;</code>和<code>&lt;slot&gt;</code>元素可以编写不在页面中显示的标记模板，然后他们可以作为自定义元素结构的基础被多次复用。</li></ol><span id="more"></span><blockquote><p>FF63+、Chrome、Opera支持，Safari支持部分web组件特性，Edge正在开发一个实现，ie不支持</p></blockquote><h1 id="Custom-elements"><a href="#Custom-elements" class="headerlink" title="Custom elements"></a>Custom elements</h1><p>共有两种custom elements</p><ul><li>Autonomous custom elements： 是独立元素，不继承自其他内建的HTML元素。可以直接写成HTML标签的形式，在页面上使用。例如<code>&lt;popup-info&gt;</code>或者是<code>document.createElement(&quot;popup-info&quot;)</code></li><li>Customized built-in elements： 继承自基本的HTML元素。在创建时，必须指定所需扩展的元素。使用时，需要先写出基本的元素标签，通过<code>is</code>属性指定custom element的名称。例如<code>&lt;p is=&quot;word-count&quot;&gt;</code>或者<code>document.createElement(&quot;p&quot;, &#123;is: &quot;word-count&quot;&#125;)</code>。</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>注册一个custom element使用<code>CustomElementRegistry.define()</code>，接收三个参数：</p><ul><li>元素名称，符合<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString">DOMString</a>标准的字符串，必须包含短横线。</li><li>用于定义元素行为的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">类</a></li><li><code>可选参数</code>：一个包含<code>extends</code>属性的配置对象，指定所创建的元素继承自哪个内置元素。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Autonomous custom element</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PopUpInfo</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">customElements.define(<span class="string">&#x27;popup-info&#x27;</span>, PopUpInfo);</span><br><span class="line"></span><br><span class="line">&lt;popup-info img=<span class="string">&quot;img/alt.png&quot;</span> text=<span class="string">&quot;some info&quot;</span>&gt;&lt;/popup-info&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Customized built-in element</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpandingList</span> <span class="keyword">extends</span> <span class="title">HTMLUListElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customElements.define(<span class="string">&#x27;expanding-list&#x27;</span>, ExpandingList, &#123;<span class="attr">extends</span>: <span class="string">&#x27;ul&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">&lt;ul is=<span class="string">&quot;expanding-list&quot;</span>&gt;&lt;/ul&gt;</span><br></pre></td></tr></table></figure><h2 id="声命周期回调函数"><a href="#声命周期回调函数" class="headerlink" title="声命周期回调函数"></a>声命周期回调函数</h2><p>在custom element的构造函数中，可以指定多个不同的回调函数，在元素的不同生命时期被调用：</p><ul><li><code>connectedCallback</code>: 首次被插入文档DOM时，被调用</li><li><code>disconnectedCallback</code>： 从文档DOM中删除时，被调用</li><li><code>adoptedCallback</code>： 被移动到新的文档时，被调用</li><li><code>attributeChangedCallback</code>： 增加、删除、修改自身属性时，被调用</li></ul><h1 id="shadow-DOM"><a href="#shadow-DOM" class="headerlink" title="shadow DOM"></a>shadow DOM</h1><p>Shadow DOM可以将一个隐藏的、独立的DOM附加到常规的DOM树中。它以shadow root节点为起始根节点，在根节点的下方，可以是任意元素，和普通的DOM元素一样。</p><p><img src="shadow-dom.png"></p><ul><li><strong>Shadow host:</strong> 一个常规的DOM节点，Shadow DOM会被附加到这个节点上</li><li><strong>Shadow tree:</strong> Shadow DOM内部的DOM树</li><li><strong>Shadow boundary:</strong> Shadow DOM结束的地方，也是常规DOM开始的地方</li><li><strong>Shadow root:</strong> Shadow tree根节点</li></ul><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><code>Element.attachShadow(&#123;mode: &#39;open&#39;|&#39;closed&#39; &#125;)</code>将一个shadow root附加到任何一个元素上。<br><code>open</code>表示可以通过页面内的js方法来获取Shadow DOM，如<code>Element.shadowRoot</code><br><code>closed</code>不可以从外部获取Shadow DOM，如浏览器内置元素如<code>&lt;video&gt;&lt;/video&gt;</code></p><blockquote><p>常规<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction">DOM（文档对象模型）</a></p></blockquote><h1 id="templates-and-slots"><a href="#templates-and-slots" class="headerlink" title="templates and slots"></a>templates and slots</h1><h2 id="templates"><a href="#templates" class="headerlink" title="templates"></a>templates</h2><p>模板可以复用相同的结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=<span class="string">&quot;my-paragraph&quot;</span>&gt;</span><br><span class="line">    &lt;p&gt;My paragraph&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>上面代码不会出现在页面中，直到使用js获取它的引用，然后添加到DOM中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> template = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;my-paragraph&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> templateContent = template.content;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(templateContent);</span><br></pre></td></tr></table></figure><h2 id="slots"><a href="#slots" class="headerlink" title="slots"></a>slots</h2><p>插槽能在单个实例中通过声明式的语法展示不同的文本。<br>slots由<code>name</code>属性标识，并且在模板中定义占位符。在实例中使用slot标记时，占位符可以填充为所需的任何HTML标记片段。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;&lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;template id=<span class="string">&quot;my-paragraph&quot;</span>&gt;</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">                &lt;slot name=<span class="string">&quot;my-text&quot;</span>&gt;</span><br><span class="line">                    My <span class="keyword">default</span> text</span><br><span class="line">                &lt;/slot&gt;</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">        &lt;my-paragraph&gt;</span><br><span class="line">            &lt;span slot=<span class="string">&quot;my-text&quot;</span>&gt;Let<span class="string">&#x27;s have some different text&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/my-paragraph&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &lt;my-paragraph&gt;</span></span><br><span class="line"><span class="string">            &lt;ul slot=&quot;my-text&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;li&gt;list 1&lt;/li&gt;</span></span><br><span class="line"><span class="string">                &lt;li&gt;list 2&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;/ul&gt;</span></span><br><span class="line"><span class="string">        &lt;/my-paragraph&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Web Components&lt;/strong&gt; 可以创建可复用的定制元素，包含三项主要技术。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Custom elements （自定义元素）：&lt;/strong&gt;JS API，可以定义custom elements及其行为，在用户界面中按需求使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shadow DOM （影子DOM）：&lt;/strong&gt;JS API，用于将封装的影子DOM树附加到元素（与主文档DOM分开呈现）并控制其关联功能。这样可以保持元素的功能私有，可以被脚本化和样式化，不会与文档的其他部分发生冲突。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HTML templates（HTML模板）：&lt;/strong&gt; &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt;元素可以编写不在页面中显示的标记模板，然后他们可以作为自定义元素结构的基础被多次复用。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>框架对比</title>
    <link href="https://chiokotomi.github.io/chio.github.io/2021/04/23/frameworksComparison/"/>
    <id>https://chiokotomi.github.io/chio.github.io/2021/04/23/frameworksComparison/</id>
    <published>2021-04-23T12:13:47.000Z</published>
    <updated>2021-04-25T13:50:32.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-vs-Vue"><a href="#React-vs-Vue" class="headerlink" title="React vs Vue"></a>React vs Vue</h1><h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><ul><li>使用虚拟Dom（Virtual Dom）</li><li>提供响应式（Reactive）和组件化（Composable）的视图组件</li><li>将注意力集中保持在核心库，而将其他功能（路由、全局状态管理）交给相关库。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React-vs-Vue&quot;&gt;&lt;a href=&quot;#React-vs-Vue&quot; class=&quot;headerlink&quot; title=&quot;React vs Vue&quot;&gt;&lt;/a&gt;React vs Vue&lt;/h1&gt;&lt;h2 id=&quot;共同点&quot;&gt;&lt;a href=&quot;#共同点&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue2学习笔记</title>
    <link href="https://chiokotomi.github.io/chio.github.io/2021/04/22/vue2/"/>
    <id>https://chiokotomi.github.io/chio.github.io/2021/04/22/vue2/</id>
    <published>2021-04-22T13:24:52.000Z</published>
    <updated>2021-04-28T13:25:06.142Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Vue是一个用于构建用户界面的渐进式框架</strong>，对于已存在的服务端应用，可将vue作为应用的一部分嵌入；如果将更多的业务逻辑放在前端，也可以用vue的核心库与生态系统来实现。<br>Vue核心库只关注视图层。</p></blockquote><span id="more"></span><h1 id="安装介绍"><a href="#安装介绍" class="headerlink" title="安装介绍"></a>安装介绍</h1><h2 id="不支持IE8"><a href="#不支持IE8" class="headerlink" title="不支持IE8"></a>不支持IE8</h2><p>实现<code>响应式系统</code>是使用<code>Object.defineProperty</code>来遍历<code>data</code>选项把所有的<code>property</code>转化为<code>getter/setter</code></p><p><code>Object.defineProperty</code>是ES5中一个无法shim的特性，这就是Vue2不支持IE8的原因。</p><h2 id="版本发布遵循语义化版本控制"><a href="#版本发布遵循语义化版本控制" class="headerlink" title="版本发布遵循语义化版本控制"></a>版本发布遵循语义化版本控制</h2><p>遵循<a href="https://semver.org/lang/zh-CN/">语义化版本控制</a></p><h2 id="构建版本"><a href="#构建版本" class="headerlink" title="构建版本"></a>构建版本</h2><ul><li>编译器： 用来将模板字符串编译成为JavaScript渲染函数的代码<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要编译器</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    template: <span class="string">&#x27;&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>运行时： 用来创建Vue实例、渲染并处理虚拟DOM等的代码。基本上就是除去编译器的其他一切。<strong>运行时版本比完整版体积小大约30%</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要编译器</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    render (h) &#123;</span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">this</span>.hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>完整版： 编译器+运行时</li></ul><h1 id="非侵入性的响应式系统"><a href="#非侵入性的响应式系统" class="headerlink" title="非侵入性的响应式系统"></a>非侵入性的响应式系统</h1><p><strong>响应式系统：</strong>修改数据模型(普通的js对象)时，视图会进行更新。这使得状态管理非常简单直接。</p><h2 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h2><blockquote><p>针对Vue实例的<code>data</code>选项（一般都传入普通的js对象）</p></blockquote><p>Vue2遍历此对象的所有<code>property</code>，使用<code>Object.defineProperty</code>把所有的<code>property</code>转化为<code>getter/setter</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue2代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">target: <span class="built_in">Object</span>, sourceKey: string, key: string</span>) </span>&#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[sourceKey][key]</span><br><span class="line">  &#125;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[sourceKey][key] = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些<code>getter/setter</code>对用户不可见，在内部可以让Vue能追踪依赖，在property被访问和修改时通知变更。<br>每个组件实例对应一个<code>watcher</code>实例，会在组件渲染的过程中把接触过的数据<code>property</code>记录为依赖，之后当依赖项的<code>setter</code>触发时，会通知<code>watcher</code>，从而使他关联的组件重新渲染。</p><p><img src="vue-data-watcher-render.jpg"></p><p>需要注意的事：</p><ul><li><p>由于js的限制，vue不能检测数组与对象的变化，使用<code>Vue.set/vm.$set</code>方法更改<code>data</code>中对象或数组的值保证他们的响应性。</p></li><li><p>data根级响应式的property不可以动态添加，必须在初始化实例时声明所有的响应式property。主要目的时消除在依赖项跟踪系统中的一类边界情况。同时提高代码的可维护性，<code>data</code>对象就像组件状态的<code>结构(schema)</code></p></li><li><p>使用Object.freeze()会阻止修改现有的property，响应系统将无法追踪变化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: obj</span><br><span class="line">&#125;)</span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;!-- 这里的 <span class="string">&#x27;foo&#x27;</span> 不会更新 --&gt;</span><br><span class="line">  &lt;button v-on:click=<span class="string">&quot;foo = &#x27;baz&#x27;&quot;</span>&gt;Change it&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h2><p>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。<br><code>Vue,nextTick(callback)</code>回调函数将在DOM更新完成后被调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">Vue.component(<span class="string">&#x27;example&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">&#x27;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&#x27;</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;未更新&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.message = <span class="string">&#x27;已更新&#x27;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;未更新&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;已更新&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 或使用ES2017 async/await</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  updateMessage: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.message = <span class="string">&#x27;已更新&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;未更新&#x27;</span></span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">this</span>.$nextTick()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;已更新&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="过渡效果系统"><a href="#过渡效果系统" class="headerlink" title="过渡效果系统"></a>过渡效果系统</h1><p>Vue插入、更新、移除元素时自动应用过渡效果</p><h1 id="Vue将模板编译成虚拟DOM渲染函数"><a href="#Vue将模板编译成虚拟DOM渲染函数" class="headerlink" title="Vue将模板编译成虚拟DOM渲染函数"></a>Vue将模板编译成虚拟DOM渲染函数</h1><h1 id="组件化应用构建"><a href="#组件化应用构建" class="headerlink" title="组件化应用构建"></a>组件化应用构建</h1><p>组件的本质：一个拥有预定义选项的Vue实例<br>大型应用中，将整个应用程序划分为组件，使开发更易管理。</p><h2 id="Vue组件与自定义元素（custom-elements）的关系"><a href="#Vue组件与自定义元素（custom-elements）的关系" class="headerlink" title="Vue组件与自定义元素（custom elements）的关系"></a>Vue组件与自定义元素（custom elements）的关系</h2><ul><li>自定义元素：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components">web组件（Web Components）规范</a>的一部分</li><li>相同点：<ul><li>Vue组件语法参考了web组件规范（例如slot API 与 <code>is</code> attribute）</li></ul></li><li>不同点：<ul><li>web components规范已通过，但并未被所有浏览器原生实现。然而vue组件不需要任何polyfill，并支持ie9及以上。必要时，Vue组件也可以包装于原生自定义元素之内。</li><li>vue组件提供了自定义元素所不具备的一些功能，例如<code>跨组件数据流</code>、<code>自定义事件通信</code>、<code>构建工具集成</code></li></ul></li></ul><h1 id="Vue实例生命周期图示"><a href="#Vue实例生命周期图示" class="headerlink" title="Vue实例生命周期图示"></a>Vue实例生命周期图示</h1><p><img src="lifecycle.png"></p><h1 id="父子组件单向数据流"><a href="#父子组件单向数据流" class="headerlink" title="父子组件单向数据流"></a>父子组件单向数据流</h1><p>所有的<code>prop</code>使得父子<code>prop</code>之间形成了一个<code>单向下行绑定</code>。以防止子组件意外更改父组件的状态，从而导致应用的数据流向难以理解。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Vue是一个用于构建用户界面的渐进式框架&lt;/strong&gt;，对于已存在的服务端应用，可将vue作为应用的一部分嵌入；如果将更多的业务逻辑放在前端，也可以用vue的核心库与生态系统来实现。&lt;br&gt;Vue核心库只关注视图层。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="vue2" scheme="https://chiokotomi.github.io/chio.github.io/tags/vue2/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化</title>
    <link href="https://chiokotomi.github.io/chio.github.io/2021/04/20/module-manage/"/>
    <id>https://chiokotomi.github.io/chio.github.io/2021/04/20/module-manage/</id>
    <published>2021-04-20T03:29:51.000Z</published>
    <updated>2021-04-26T13:17:08.424Z</updated>
    
    <content type="html"><![CDATA[<p>模块化的开发方式可以提高代码<strong>复用率</strong>，方便代码管理。一般一<strong>个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数</strong>。模块化开发的核心问题就是引入js文件的<strong>顺序问题</strong>以及<strong>异步加载问题</strong>。</p><p>ES6之前，原生不支持模块化，所以出现了第三方的解决方案，分别是<code>AMD</code>与<code>CMD</code>，NodeJs诞生后使用<code>CommonJs</code>的模块化规范。</p><span id="more"></span><h1 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h1><p>异步模块定义<code>Asynchronous Module Definition</code>，是<code>RequireJs</code>在推广过程中对模块定义的规范化的产出。采用<strong>异步方式加载模块</strong>，模块的加载不影响后面的语句运行。所有依赖这个模块的语句，都定义在回调函数中。</p><p>用require.js实现AMD规范的模块化：用<code>require.config()</code>指定引用路径，用<code>define()</code>定义模块，用<code>require()</code>加载模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网页中引入require.js与main.js(配置require.config()规定用到的基础模块)</span></span><br><span class="line">&lt;script src=<span class="string">&quot;js/require.js&quot;</span> data-main=<span class="string">&quot;js/main&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js 入口文件</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">&#x27;js/lib&#x27;</span>,</span><br><span class="line">    paths: &#123;</span><br><span class="line">        <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;jquery.min&quot;</span>,</span><br><span class="line">        <span class="string">&quot;underscore&quot;</span>: <span class="string">&quot;underscore.min&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>引入模块时，将模块名放在<code>[]</code>中作为<code>require()</code>的第一参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义math.js模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add: add,</span><br><span class="line">        basicNum: basicNum</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入模块</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;jquery&#x27;</span>, <span class="string">&#x27;math&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$, math</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum = math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    $(<span class="string">&quot;$sum&quot;</span>).htm(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>若定义的模块依赖其他模块，则需要放在<code>[]</code>中作为<code>define</code>的第一个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">&#x27;underscore&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">_</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> classify = <span class="function"><span class="keyword">function</span> (<span class="params">list</span>) </span>&#123;</span><br><span class="line">        _.countBy(list, <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num &gt; <span class="number">30</span> ? <span class="string">&#x27;old&#x27;</span> : <span class="string">&#x27;young&#x27;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">classify</span>: classify&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><p>通用模块加载规范<code>Common Module Definition</code>，是<code>Sea.js</code>实现的规范。</p><p>AMD实现者require.js在申明依赖的模块时，会第一时间加载并执行模块内代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AMD写法</span></span><br><span class="line"><span class="comment">// 声明并初始化所有要用到的模块</span></span><br><span class="line">define([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 即使未用到模块b，b依旧会提前执行 **这就是CMD要优化的地方**</span></span><br><span class="line">        b.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>CMD与AMD类似，不同点在于：<strong>AMD推崇依赖前置，提前执行，CMD推崇依赖就近，延迟执行</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMD写法</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="keyword">export</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>);</span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>);</span><br><span class="line">        b.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sea.js</span></span><br><span class="line"><span class="comment">// 定义模块math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="keyword">export</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery.js&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">export</span>.add = add;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">&#x27;math.js&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = math.add(<span class="number">2</span> + <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h1><p>NodeJS是主要实践者，需要四个重要的环境变量为模块化的实现提供支持<code>module</code>、<code>exports</code>、<code>require</code>、<code>global</code>。<br><code>module.exports</code>定义对外输出的接口，<code>require</code>加载模块。</p><blockquote><p>问题：<br>CommonJS用<strong>同步</strong>的方式加载模块。在服务器端，模块文件存放本地磁盘，读取非常快。<strong>但在浏览器端，限于网络原因，更合理的方案是使用异步加载</strong>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义模块math.js</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    add: add,</span><br><span class="line">    basicNum: basicNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入自定义模块</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./math&#x27;</span>);</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h1 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h1><p>UMD（Universal Module Definition）是AMD和CommonJs的统一规范，支持两种规范，写一套代码，可用于多种场景。</p><ul><li>写法最复杂</li><li>前后端通用</li><li>UMD更像是一种配置多个模块系统的模式</li><li>UMD在使用诸如Rollup/Webpack之类的bundler时通常用作备用模块</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        <span class="comment">// AMD</span></span><br><span class="line">        define([<span class="string">&#x27;jquery]&#x27;</span>, factory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// Node CommonJs</span></span><br><span class="line">        <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">&#x27;jquery&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 浏览器全局变量</span></span><br><span class="line">        root.returnExports = factory(root.jquery);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="built_in">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定义方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">myFunc</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暴露公共方法</span></span><br><span class="line">    <span class="keyword">return</span> myFunc;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="ESM-ES6-Module"><a href="#ESM-ES6-Module" class="headerlink" title="ESM / ES6 Module"></a>ESM / ES6 Module</h1><blockquote><p>ES6在语言标准层面上，实现了模块功能。成为浏览器和服务器通用的模块解决方案。<br>ES6模块不是对象，<code>import</code>命令会被js引擎静态分析，在编译时就引入模块代码，而且不在运行时加载，所以无法实现条件加载。</p></blockquote><p>主要包含两个命令：<code>export</code>规定对外接口，<code>import</code>输入其他模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义math.js</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;basicNum, add&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">import</span> &#123;basicNum, add&#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    ele.textContent =  add(<span class="number">99</span> + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ES6模块与CommonJS模块差异"><a href="#ES6模块与CommonJS模块差异" class="headerlink" title="ES6模块与CommonJS模块差异"></a>ES6模块与CommonJS模块差异</h1><h2 id="CommonJs模块输出的是一个值的拷贝，ES6模块输出的是值的引用"><a href="#CommonJs模块输出的是一个值的拷贝，ES6模块输出的是值的引用" class="headerlink" title="CommonJs模块输出的是一个值的拷贝，ES6模块输出的是值的引用"></a>CommonJs模块输出的是一个值的拷贝，ES6模块输出的是值的引用</h2><ul><li>CommonJs模块输出的是一个<strong>值的拷贝</strong>，一旦输出一个值，模块内部的变化影响不到这个值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">num</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    b = &#123;<span class="attr">num</span>: <span class="number">2</span>&#125;;</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;a, b&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">let</span> &#123;a, b&#125; = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b);   <span class="comment">// &#123;num: 1&#125;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(b);   <span class="comment">// &#123;num: 1&#125;</span></span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure></li></ul><p><strong>输出拷贝<code>exports</code>对象是模块内外的唯一关联，CommonJs输出的内容，就是<code>exports</code>对象的属性，模块运行结束，属性就确定了。</strong></p><ul><li>ES6模块的运行机制：JS引擎对脚本静态分析时，遇到<code>import</code>会生成一个<strong>只读引用</strong>。在脚本真正执行时，再根据引用到被加载的模块里去取值。ES6模块是动态引用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">num</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    b = &#123;<span class="attr">num</span>: <span class="number">2</span>&#125;;</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    a,</span><br><span class="line">    b</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;a, b&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// &#123;num: 1&#125;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(b);  <span class="comment">// &#123;num: 2&#125;</span></span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="CommonJs模块时运行时加载，ES6模块时编译时输出"><a href="#CommonJs模块时运行时加载，ES6模块时编译时输出" class="headerlink" title="CommonJs模块时运行时加载，ES6模块时编译时输出"></a>CommonJs模块时运行时加载，ES6模块时编译时输出</h2><ul><li>运行时加载： 输入时先加载整个模块，生成一个对象，再从这个对象上读取方法。</li><li>编译时加载： <code>import</code>时指定加载某个输出值，而不是加载整个模块。模块内部引用的变化，会反应在外部。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;模块化的开发方式可以提高代码&lt;strong&gt;复用率&lt;/strong&gt;，方便代码管理。一般一&lt;strong&gt;个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数&lt;/strong&gt;。模块化开发的核心问题就是引入js文件的&lt;strong&gt;顺序问题&lt;/strong&gt;以及&lt;strong&gt;异步加载问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;ES6之前，原生不支持模块化，所以出现了第三方的解决方案，分别是&lt;code&gt;AMD&lt;/code&gt;与&lt;code&gt;CMD&lt;/code&gt;，NodeJs诞生后使用&lt;code&gt;CommonJs&lt;/code&gt;的模块化规范。&lt;/p&gt;</summary>
    
    
    
    
    <category term="module" scheme="https://chiokotomi.github.io/chio.github.io/tags/module/"/>
    
  </entry>
  
  <entry>
    <title>面向对象编程与函数式编程</title>
    <link href="https://chiokotomi.github.io/chio.github.io/2021/04/20/oop-fp/"/>
    <id>https://chiokotomi.github.io/chio.github.io/2021/04/20/oop-fp/</id>
    <published>2021-04-20T03:19:02.000Z</published>
    <updated>2021-04-21T01:31:37.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程与函数式编程"><a href="#面向对象编程与函数式编程" class="headerlink" title="面向对象编程与函数式编程"></a>面向对象编程与函数式编程</h1><p><a href="https://dev.to/bhaveshdaswani93/oop-vs-fp-with-javascript-39jf">oop vs fp</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面向对象编程与函数式编程&quot;&gt;&lt;a href=&quot;#面向对象编程与函数式编程&quot; class=&quot;headerlink&quot; title=&quot;面向对象编程与函数式编程&quot;&gt;&lt;/a&gt;面向对象编程与函数式编程&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://dev.to/bhaves</summary>
      
    
    
    
    
    <category term="oop" scheme="https://chiokotomi.github.io/chio.github.io/tags/oop/"/>
    
  </entry>
  
  <entry>
    <title>es5-es6-es7</title>
    <link href="https://chiokotomi.github.io/chio.github.io/2021/04/14/es5-es6-es7/"/>
    <id>https://chiokotomi.github.io/chio.github.io/2021/04/14/es5-es6-es7/</id>
    <published>2021-04-14T13:14:48.000Z</published>
    <updated>2021-04-26T03:57:27.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h1><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN doc</a> </p><blockquote><p>taken from stackoverflow</p></blockquote><p>Property is an OOP feature designed for clean separation of client code. For example, in some e-shop you might have objects like this:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name,price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line">  <span class="built_in">this</span>.discount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sneakers = <span class="keyword">new</span> Product(<span class="string">&quot;Sneakers&quot;</span>,<span class="number">20</span>); <span class="comment">// &#123;name:&quot;Sneakers&quot;,price:20,discount:0&#125;</span></span><br><span class="line"><span class="keyword">var</span> tshirt = <span class="keyword">new</span> Product(<span class="string">&quot;T-shirt&quot;</span>,<span class="number">10</span>);  <span class="comment">// &#123;name:&quot;T-shirt&quot;,price:10,discount:0&#125;</span></span><br></pre></td></tr></table></figure><p>Then in your client code (the e-shop), you can add discounts to your products:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">badProduct</span>(<span class="params">obj</span>) </span>&#123; obj.discount+= <span class="number">20</span>; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generalDiscount</span>(<span class="params">obj</span>) </span>&#123; obj.discount+= <span class="number">10</span>; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distributorDiscount</span>(<span class="params">obj</span>) </span>&#123; obj.discount+= <span class="number">15</span>; ... &#125;</span><br></pre></td></tr></table></figure><p>Later, the e-shop owner might realize that the discount can’t be greater than say 80%. Now you need to find EVERY occurrence of the discount modification in the client code and add a line</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj.discount&gt;<span class="number">80</span>) obj.discount = <span class="number">80</span>;</span><br></pre></td></tr></table></figure><p>Then the e-shop owner may further change his strategy, like “if the customer is reseller, the maximal discount can be 90%”. And you need to do the change on multiple places again plus you need to remember to alter these lines anytime the strategy is changed. This is a bad design. That’s why encapsulation is the basic principle of OOP. If the constructor was like this:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name,price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _name=name, _price=price, _discount=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line">  <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; _name = value; &#125;</span><br><span class="line">  <span class="built_in">this</span>.getPrice = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> _price; &#125;</span><br><span class="line">  <span class="built_in">this</span>.setPrice = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; _price = value; &#125;</span><br><span class="line">  <span class="built_in">this</span>.getDiscount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> _discount; &#125;</span><br><span class="line">  <span class="built_in">this</span>.setDiscount = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; _discount = value; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then you can just alter the getDiscount (accessor) and setDiscount (mutator) methods. The problem is that most of the members behave like common variables, just the discount needs special care here. But good design requires encapsulation of every data member to keep the code extensible. So you need to add lots of code that does nothing. This is also a bad design, a boilerplate antipattern. Sometimes you can’t just refactor the fields to methods later (the eshop code may grow large or some third-party code may depend on the old version), so the boilerplate is lesser evil here. But still, it is evil. That’s why properties were introduced into many languages. You could keep the original code, just transform the discount member into a property with get and set blocks:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name,price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line"><span class="comment">//this.discount = 0; // &lt;- remove this line and refactor with the code below</span></span><br><span class="line">  <span class="keyword">var</span> _discount; <span class="comment">// private member</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>,<span class="string">&quot;discount&quot;</span>,&#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> _discount; &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; _discount = value; <span class="keyword">if</span>(_discount&gt;<span class="number">80</span>) _discount = <span class="number">80</span>; &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the client code</span></span><br><span class="line"><span class="keyword">var</span> sneakers = <span class="keyword">new</span> Product(<span class="string">&quot;Sneakers&quot;</span>,<span class="number">20</span>);</span><br><span class="line">sneakers.discount = <span class="number">50</span>; <span class="comment">// 50, setter is called</span></span><br><span class="line">sneakers.discount+= <span class="number">20</span>; <span class="comment">// 70, setter is called</span></span><br><span class="line">sneakers.discount+= <span class="number">20</span>; <span class="comment">// 80, not 90!</span></span><br><span class="line">alert(sneakers.discount); <span class="comment">// getter is called</span></span><br></pre></td></tr></table></figure><p>Note the last but one line: the responsibility for correct discount value was moved from the client code (e-shop definition) to the product definition. The product is responsible for keeping its data members consistent. Good design is (roughly said) if the code works the same way as our thoughts.</p><p>So much about properties. But javascript is different from pure Object-oriented languages like C# and codes the features differently:</p><p>In C#, transforming fields into properties is a breaking change, so public fields should be coded as Auto-Implemented Properties if your code might be used in the separately compiled client.</p><p>In Javascript, the standard properties (data member with getter and setter described above) are defined by accessor descriptor (in the link you have in your question). Exclusively, you can use data descriptor (so you can’t use i.e. value and set on the same property):</p><ul><li><p>accessor descriptor = get + set (see the example above)</p><ul><li>get must be a function; its return value is used in reading the property; if not specified, the default is undefined, which behaves like a function that returns undefined</li><li>set must be a function; its parameter is filled with RHS in assigning a value to property; if not specified, the default is undefined, which behaves like an empty function</li></ul></li><li><p>data descriptor = value + writable (see the example below)</p><ul><li>value default undefined; if writable, configurable and enumerable (see below) are true, the property behaves like an ordinary data field</li><li>writable - default false; if not true, the property is read only; attempt to write is ignored without error*!<br>Both descriptors can have these members:</li></ul></li><li><p>configurable - default false; if not true, the property can’t be deleted; attempt to delete is ignored without error*!</p></li><li><p>enumerable - default false; if true, it will be iterated in for(var i in theObject); if false, it will not be iterated, but it is still accessible as public</p></li></ul><ul><li>unless in strict mode - in that case JS stops execution with TypeError unless it is caught in try-catch block</li></ul><p>To read these settings, use Object.getOwnPropertyDescriptor().</p><p>Learn by example:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&quot;test&quot;</span>,&#123;</span><br><span class="line">  value: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&quot;test&quot;</span>)); <span class="comment">// check the settings    </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> o) <span class="built_in">console</span>.log(o[i]); <span class="comment">// nothing, o.test is not enumerable</span></span><br><span class="line"><span class="built_in">console</span>.log(o.test); <span class="comment">// &quot;a&quot;</span></span><br><span class="line">o.test = <span class="string">&quot;b&quot;</span>; <span class="comment">// o.test is still &quot;a&quot;, (is not writable, no error)</span></span><br><span class="line"><span class="keyword">delete</span>(o.test); <span class="comment">// bye bye, o.test (was configurable)</span></span><br><span class="line">o.test = <span class="string">&quot;b&quot;</span>; <span class="comment">// o.test is &quot;b&quot;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> o) <span class="built_in">console</span>.log(o[i]); <span class="comment">// &quot;b&quot;, default fields are enumerable</span></span><br></pre></td></tr></table></figure><p>If you don’t wish to allow the client code such cheats, you can restrict the object by three levels of confinement:</p><ul><li>Object.preventExtensions(yourObject) prevents new properties to be added to yourObject. Use Object.isExtensible(<yourObject>) to check if the method was used on the object. The prevention is shallow (read below).</li><li>Object.seal(yourObject) same as above and properties can not be removed (effectively sets configurable: false to all properties). Use Object.isSealed(<yourObject>) to detect this feature on the object. The seal is shallow (read below).</li><li>Object.freeze(yourObject) same as above and properties can not be changed (effectively sets writable: false to all properties with data descriptor). Setter’s writable property is not affected (since it doesn’t have one). The freeze is shallow: it means that if the property is Object, its properties ARE NOT frozen (if you wish to, you should perform something like “deep freeze”, similar to deep copy - cloning). Use Object.isFrozen(<yourObject>) to detect it.</li></ul><p>You don’t need to bother with this if you write just a few lines fun. But if you want to code a game (as you mentioned in the linked question), you should care about good design. Try to google something about antipatterns and code smell. It will help you to avoid situations like “Oh, I need to completely rewrite my code again!”, it can save you months of despair if you want to code a lot.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;es6&quot;&gt;&lt;a href=&quot;#es6&quot; class=&quot;headerlink&quot; title=&quot;es6&quot;&gt;&lt;/a&gt;es6&lt;/h1&gt;&lt;h2 id=&quot;Object-defineProperty&quot;&gt;&lt;a href=&quot;#Object-defineProperty&quot; class</summary>
      
    
    
    
    
    <category term="es6" scheme="https://chiokotomi.github.io/chio.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>vue3学习笔记</title>
    <link href="https://chiokotomi.github.io/chio.github.io/2021/04/10/vue3/"/>
    <id>https://chiokotomi.github.io/chio.github.io/2021/04/10/vue3/</id>
    <published>2021-04-10T15:13:43.000Z</published>
    <updated>2021-04-22T13:29:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>vue3 比 vue2 加了什么功能</li><li>vue 设计思想，实现了什么功能，怎么实现的</li><li>vue 支持到的ie版本</li><li>vue 生态其他库的作用是什么</li><li>vue3跟typescript关系是什么，好用在哪里</li><li>预渲染与服务端渲染如何实现的</li></ul><h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><h2 id="放弃支持IE11"><a href="#放弃支持IE11" class="headerlink" title="放弃支持IE11"></a>放弃支持IE11</h2><blockquote><p>参考vue RFC <a href="https://github.com/vuejs/rfcs/blob/ie11/active-rfcs/0000-vue3-ie11-support.md">proposal for dropping ie11 support in Vue3</a></p></blockquote><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ol><li>浏览器和js的环境发生变化，越来越多的开发者开始使用现代语言特性</li><li>微软通过投资Edge推动用户停止对IE的使用，同时在自己的<code>Microsoft 365</code>重大项目中放弃使用IE11</li><li>WordPress放弃支持IE11</li><li>IE11全球使用率跌破1%以下</li></ol><h3 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h3><h4 id="1-行为不一致"><a href="#1-行为不一致" class="headerlink" title="1. 行为不一致"></a>1. 行为不一致</h4><ul><li><p>原因：<code>响应式系统的实现</code>在<code>vue2</code>中基于<code>ES5的getter/setter</code>，在<code>vue3</code>中基于<code>ES2015 Proxies</code>，更高性能更完整的响应式系统。ie11中无法<code>polyfill</code>这些特性。</p></li><li><p>好处： <code>vue3基于Proxy</code>的响应式系统提供了<code>近乎完整的</code>语言特性覆盖：可以检测到许多在ES5中不可行或不可能的操作，如<code>属性的添加/删除</code>、<code>数组索引和长度突变</code>以及<code>in操作符的检查等功能</code>。</p></li><li><p>支持方案：使vue3在ie11版本的开发构建中同时发布<code>Proxy</code>和<code>ES5</code>两种响应性版本。</p></li><li><p>结论： 理论可行，复杂度大，需要将两种实现混合在一起，可能导致<em><strong>开发和生产之间的行为差异</strong></em></p></li></ul><h4 id="2-长期维护负担"><a href="#2-长期维护负担" class="headerlink" title="2. 长期维护负担"></a>2. 长期维护负担</h4><p>支持ie11就必须考虑整个代码库中使用的语言特性与为发布版本找到合适的polyfill编译策略。</p><p>每一个不能在ie11中被polyfill的新特性都会带来新的行为警告</p><h4 id="3-库作者的复杂性"><a href="#3-库作者的复杂性" class="headerlink" title="3. 库作者的复杂性"></a>3. 库作者的复杂性</h4><p>两个响应性实现也会不可避免的影响vue生态其他库作者开发，若决定支持IE11，在编写库时，需要时刻考虑ES5响应系统的一些缺陷。</p><h2 id="新功能"><a href="#新功能" class="headerlink" title="新功能"></a>新功能</h2><ul><li>composition API</li><li><code>&lt;script setup&gt;</code> 与其他新的<code>单文件组件(SFC)</code>特性</li><li>emits 选项</li><li>TS 类型改进</li><li>Vite官方整合</li></ul><h1 id="Next-To-Learn"><a href="#Next-To-Learn" class="headerlink" title="Next To Learn"></a>Next To Learn</h1><ul><li>data 属性设定与作用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;vue3 比 vue2 加了什么功能&lt;/li&gt;
&lt;li&gt;vue 设计思想，实现了什么功能，怎么实现的&lt;/li&gt;
&lt;li&gt;vue </summary>
      
    
    
    
    
    <category term="vue" scheme="https://chiokotomi.github.io/chio.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>学习列表</title>
    <link href="https://chiokotomi.github.io/chio.github.io/2021/04/09/to-learn-list/"/>
    <id>https://chiokotomi.github.io/chio.github.io/2021/04/09/to-learn-list/</id>
    <published>2021-04-09T02:11:02.000Z</published>
    <updated>2021-04-21T02:59:10.340Z</updated>
    
    <content type="html"><![CDATA[<ul><li>vue</li><li>react</li><li>webpack</li><li>babel/polyfill</li><li>ng</li><li>es6 es7</li><li>架构师</li><li>重构</li><li>数据结构与算法</li><li>leetcode</li><li>d3.js</li><li>bootstrap/wordpress</li><li>微服务、懒加载、预渲染、服务端渲染</li><li>性能优化</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;vue&lt;/li&gt;
&lt;li&gt;react&lt;/li&gt;
&lt;li&gt;webpack&lt;/li&gt;
&lt;li&gt;babel/polyfill&lt;/li&gt;
&lt;li&gt;ng&lt;/li&gt;
&lt;li&gt;es6 es7&lt;/li&gt;
&lt;li&gt;架构师&lt;/li&gt;
&lt;li&gt;重构&lt;/li&gt;
&lt;li&gt;数据结构与算法&lt;</summary>
      
    
    
    
    
    <category term="oop" scheme="https://chiokotomi.github.io/chio.github.io/tags/oop/"/>
    
  </entry>
  
</feed>
